[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Manual de Julia",
    "section": "",
    "text": "¡Bienvenido al Manual de Julia!\nEste libro presenta una introducción al lenguaje de programación Julia con un enfoque orientado al cálculo científico y el análisis de datos.\n\n\nEsta obra está bajo una licencia Reconocimiento – No comercial – Compartir bajo la misma licencia 3.0 España de Creative Commons. Para ver una copia de esta licencia, visite https://creativecommons.org/licenses/by-nc-sa/3.0/es/.\nCon esta licencia eres libre de:\n\nCopiar, distribuir y mostrar este trabajo.\nRealizar modificaciones de este trabajo.\n\nBajo las siguientes condiciones:\n\nReconocimiento. Debe reconocer los créditos de la obra de la manera especificada por el autor o el licenciador (pero no de una manera que sugiera que tiene su apoyo o apoyan el uso que hace de su obra).\nNo comercial. No puede utilizar esta obra para fines comerciales.\nCompartir bajo la misma licencia. Si altera o transforma esta obra, o genera una obra derivada, sólo puede distribuir la obra generada bajo una licencia idéntica a ésta.\n\nAl reutilizar o distribuir la obra, tiene que dejar bien claro los términos de la licencia de esta obra.\nEstas condiciones pueden no aplicarse si se obtiene el permiso del titular de los derechos de autor.\nNada en esta licencia menoscaba o restringe los derechos morales del autor."
  },
  {
    "objectID": "intro.html",
    "href": "intro.html",
    "title": "1  Introducción",
    "section": "",
    "text": "Julia es otro lenguaje de programación más, orientado a cálculo científico el análisis de datos similar a Python, R o Matlab.\n¿De veras necesitamos aprender otro lenguaje más?"
  },
  {
    "objectID": "intro.html#qué-pretende-ser-julia",
    "href": "intro.html#qué-pretende-ser-julia",
    "title": "1  Introducción",
    "section": "1.2 ¿Qué pretende ser Julia?",
    "text": "1.2 ¿Qué pretende ser Julia?\nDe los creadores de Julia:\n\nWe want a language that is:\n\nOpen source.\nWith the speed of C.\nObvious, familiar mathematical notation like Matlab.\nAs usable for general programming as Python.\nAs easy for statistics as R.\nAs natural for string processing as Perl.\nAs powerful for linear algebra as Matlab.\nAs good at gluing programs together as the shell.\nDirt simple to learn, yet keeps the most serious hackers happy."
  },
  {
    "objectID": "intro.html#qué-es-julia",
    "href": "intro.html#qué-es-julia",
    "title": "1  Introducción",
    "section": "1.3 ¿Qué es Julia?",
    "text": "1.3 ¿Qué es Julia?\n\nJulia es un lenguaje de alto nivel con una sintaxis fácil de aprender (similar a Python, R o Matlab) que permite escribir símbolos matemáticos en las expresiones (UTF-8).\nJulia es un lenguaje muy veloz (equiparable a C en muchas tareas.)\nLenguaje dinámico (tipado dinámico y despacho múltiple).\nDe propósito general, pero orientado a la computación científica y el análisis de grandes volúmenes de datos.\nCreado en 2019 en el MIT por el equipo del profesor Edelman.\nÚltima versión: 1.7 (bastante maduro).\nDesarrollado por una gran comunidad científica.\nRepositorio de paquetes de código abierto con más de 3000 paquetes en dominios muy diversos.\n\n\n1.3.1 Comparativa de rapidez de Julia con otros lenguajes\n\n\n\nComparativa de Julia con otros lenguajes"
  },
  {
    "objectID": "intro.html#algunas-razones-más-para-pensárselo",
    "href": "intro.html#algunas-razones-más-para-pensárselo",
    "title": "1  Introducción",
    "section": "1.4 Algunas razones más para pensárselo",
    "text": "1.4 Algunas razones más para pensárselo\n\nEvita el problema de la doble reescritura de código (prototipo + versión operativa).\nPermite la programación paralela y distribuida.\nPuede ejecutar código realizado en otros lenguajes como C, Fortran, Python, R, Matlab, etc."
  },
  {
    "objectID": "intro.html#instalación-de-julia",
    "href": "intro.html#instalación-de-julia",
    "title": "1  Introducción",
    "section": "1.5 Instalación de Julia",
    "text": "1.5 Instalación de Julia\n\nDescargar e instalar Julia.\nAñadir Julia al PATH del sistema.\n\nUna vez instalado, para ejecutar el intérprete de Julia basta con abrir una terminal y teclear julia.\nprompt> julia\n               _\n   _       _ _(_)_     |  Documentation: https://docs.julialang.org\n  (_)     | (_) (_)    |\n   _ _   _| |_  __ _   |  Type \"?\" for help, \"]?\" for Pkg help.\n  | | | | | | |/ _` |  |\n  | | |_| | | | (_| |  |  Version 1.7.3 (2022-05-06)\n _/ |\\__'_|_|_|\\__'_|  |  Official https://julialang.org/ release\n|__/                   |\n\njulia>"
  },
  {
    "objectID": "intro.html#el-repl-de-julia",
    "href": "intro.html#el-repl-de-julia",
    "title": "1  Introducción",
    "section": "1.6 El REPL de Julia",
    "text": "1.6 El REPL de Julia\nEl REPL1 de Julia permite ejecutar código de Julia tecleándolo directamente en la terminal.\njulia> 2 + 3\n5\nTiene, además, varios modos:\n\n; para abrir el modo shell.\n] para abrir el modo de gestión de paquetes.\n? para abrir el modoe de ayuda.to open help mode\n<backspace> para volver al modo normal."
  },
  {
    "objectID": "intro.html#el-gestor-de-paquetes-de-julia",
    "href": "intro.html#el-gestor-de-paquetes-de-julia",
    "title": "1  Introducción",
    "section": "1.7 El gestor de paquetes de Julia",
    "text": "1.7 El gestor de paquetes de Julia\nComo en otros lenguajes, es posible crear módulos o paquetes con código que puede ser reutilizado. Julia tiene un potente gestor de paquetes que facilita la búsqueda, instalación, actualización y eliminación de paquetes.\nPor defecto el gestor de paquetes utiliza el repositorio de paquetes oficial pero se pueden instalar paquetes de otros repositorios.\nPara entrar en el modo de gestión de paquetes hay que teclear ]. Esto produce un cambio en el prompt del REPL de Julia.\nLos comandos más habituales son:\n\nadd p: Instala el paquete p en el entorno activo de Julia.\nupdate: Actualiza los paquetes del entorno activo de Julia.\nstatus: Muestra los paquetes instalados y sus versiones en el entorno activo de Julia.\nremove p: Elimina el paquete p del entorno activo de Julia.\n\nEjemplo\n(@v1.7) pkg> add CSV\n   Resolving package versions...\n   Installed CodecZlib ────────── v0.7.0\n   Installed SentinelArrays ───── v1.3.13\n   Installed WeakRefStrings ───── v1.4.2\n   Installed InlineStrings ────── v1.1.4\n   Installed FilePathsBase ────── v0.9.18\n   Installed TranscodingStreams ─ v0.9.6\n   Installed CSV ──────────────── v0.10.4\n    Updating `~/.julia/environments/v1.7/Project.toml`\n  [336ed68f] + CSV v0.10.4\n    Updating `~/.julia/environments/v1.7/Manifest.toml`\n  [336ed68f] + CSV v0.10.4\n  [944b1d66] + CodecZlib v0.7.0\n  [48062228] + FilePathsBase v0.9.18\n  [842dd82b] + InlineStrings v1.1.4\n  [91c51154] + SentinelArrays v1.3.13\n  [3bb67fe8] + TranscodingStreams v0.9.6\n  [ea10d353] + WeakRefStrings v1.4.2\nPrecompiling project..."
  },
  {
    "objectID": "intro.html#entornos-de-desarrollo",
    "href": "intro.html#entornos-de-desarrollo",
    "title": "1  Introducción",
    "section": "1.8 Entornos de desarrollo",
    "text": "1.8 Entornos de desarrollo\nCuando se trabaja en el desarrollo de varias aplicaciones, es habitual crear entornos de desarrollo individuales para instalar los paquetes de los que dependan y que no interfieran con los de otras aplicaciones.\nBásicamente, un entorno de desarrollo es un directorio con código de Julia que contiene dos ficheros Project.toml y Manifest.toml que contienen los paquetes instalados en el entorno y sus dependencias.\nPara crear y activar un entorno de desarrollo se utilizan los siguiente comandos en el modo de gestión de paquetes:\n\ngenerate dir: Crea el directorio dir y lo convierte en un entorno de desarrollo de Julia.\nactivate dir: Convierte en el entorno de desarrollo dir en el entorno activo dentro de la sesión de Julia. A partir de entonces, cualquier paquete que se instale o actualice será dentro de ese entorno.\n\nEjemplo\n(@v1.7) pkg> generate app\n  Generating  project app:\n    app/Project.toml\n    app/src/app.jl\n\n(@v1.7) pkg> activate app\n  Activating project at `~/app`\n\n(app) pkg> add CSV # Instalar última versión del paquete CSV\n...\n(app) pkg> add DataFrames@v1.3.0;  # Instalar la versión 1.3.0 del paquete DataFrames\n...\n(app) pkg> status\n     Project app v0.1.0\n      Status `~/app/Project.toml`\n  [336ed68f] CSV v0.10.4\n  [a93c6f00] DataFrames v1.3.0"
  },
  {
    "objectID": "intro.html#ides-para-julia",
    "href": "intro.html#ides-para-julia",
    "title": "1  Introducción",
    "section": "1.9 IDEs para Julia",
    "text": "1.9 IDEs para Julia\n\n\n1.9.1 Visual studio code\n\nDescargar e instalar VSCode.\nInstalar la extensión de Julia.\n\n\n\n\nVisual Studio Code con la extensión para Julia\n\n\n\n\n1.9.2 Jupyter\n\nDescargar e instalar Python\nDescargar e instalar Jupyter\nInstalar el paquete IJulia:\n\njulia> using Pkg\njulia> Pkg.add(\"IJulia\")\n\n\n\nJupyter con el kernel de Julia\n\n\n\n\n1.9.3 Pluto\nPluto es entorno de desarrollo propio de Julia similar a Jupyter. Pluto permite crear notebooks reactivos cuyas celdas se actualizan cada vez que se produce un cambio en el estado del programa.\nPara usarlo basta instalar el paquete Pluto.jl.\njulia> using Pkg\n\njulia> Pkg.add(\"Pluto\");\n\njulia> using Pluto\n\njulia> Pluto.run()\n[ Info: Loading...\n┌ Info: \n└ Opening http://localhost:1234/?secret=a63iBsIL in your default browser... ~ have fun!\n┌ Info: \n│ Press Ctrl+C in this terminal to stop Pluto\n└ \nOpening in existing browser session.\n\n\n\nPágina inicial de Pluto"
  },
  {
    "objectID": "tipos-datos.html",
    "href": "tipos-datos.html",
    "title": "2  Tipos de datos y variables",
    "section": "",
    "text": "Enteros: Int64 (64 bits por defecto).\nRacionales: Rational{Int64}. Utilizando el operador //.\nReales: Float64 (64 bits por defecto).\nComplejos: Complex{Int64}. Utilizando im después de la parte imaginaria.\n\nPara averiguar el tipo de un dato se utiliza la función typeof()."
  },
  {
    "objectID": "tipos-datos.html#ejemplos-de-tipos-de-datos-numéricos",
    "href": "tipos-datos.html#ejemplos-de-tipos-de-datos-numéricos",
    "title": "2  Tipos de datos y variables",
    "section": "2.2 Ejemplos de tipos de datos numéricos",
    "text": "2.2 Ejemplos de tipos de datos numéricos\njulia> typeof(3)\nInt64\n\njulia> typeof(3/2)\nFloat64\n\njulia> typeof(3//2)\nRational{Int64}\n\njulia> typeof(π)\nIrrational{:π}\n\njulia> typeof(3+2im)\nComplex{Int64}"
  },
  {
    "objectID": "tipos-datos.html#jerarquía-de-tipos-de-datos-numéricos",
    "href": "tipos-datos.html#jerarquía-de-tipos-de-datos-numéricos",
    "title": "2  Tipos de datos y variables",
    "section": "2.3 Jerarquía de tipos de datos numéricos",
    "text": "2.3 Jerarquía de tipos de datos numéricos"
  },
  {
    "objectID": "tipos-datos.html#constantes-predefinidas",
    "href": "tipos-datos.html#constantes-predefinidas",
    "title": "2  Tipos de datos y variables",
    "section": "2.4 Constantes predefinidas",
    "text": "2.4 Constantes predefinidas\n\n\n\nSímbolo\nDescripción\n\n\n\n\npi o π\nNúmero irracional \\(\\pi\\)\n\n\nℯ (\\euler + TAB)\nNúmero irracional \\(e\\)\n\n\nInf\nInfinito\n\n\nNaN\nValor no numérico\n\n\nMissing\nValor desconocido"
  },
  {
    "objectID": "tipos-datos.html#ejemplo-de-constantes-predefinidas",
    "href": "tipos-datos.html#ejemplo-de-constantes-predefinidas",
    "title": "2  Tipos de datos y variables",
    "section": "2.5 Ejemplo de constantes predefinidas",
    "text": "2.5 Ejemplo de constantes predefinidas\njulia> π\nπ = 3.1415926535897...\n\njulia> 1 / 0\nInf\n\njulia> 0 / 0\nNaN\n\njulia> Inf + Inf\nInf\n\njulia> Inf - Inf\nNaN\n\njulia> 0 * Inf\nNaN"
  },
  {
    "objectID": "tipos-datos.html#tipos-de-datos-alfanuméricos",
    "href": "tipos-datos.html#tipos-de-datos-alfanuméricos",
    "title": "2  Tipos de datos y variables",
    "section": "2.6 Tipos de datos alfanuméricos",
    "text": "2.6 Tipos de datos alfanuméricos\n\nCaracteres: Char. Se representan entre comillas simples.\nCadenas: String. Se representan entre comillas dobles.\n\njulia> typeof('a')\nChar\n\njulia> typeof(\"julia\")\nString\n\njulia> typeof(\"a\")\nString"
  },
  {
    "objectID": "tipos-datos.html#tipo-de-datos-booleanos",
    "href": "tipos-datos.html#tipo-de-datos-booleanos",
    "title": "2  Tipos de datos y variables",
    "section": "2.7 Tipo de datos booleanos",
    "text": "2.7 Tipo de datos booleanos\n\nBooleanos: bool. Son un subtipo de los enteros Integer.\n\nSolo contienen dos posibles valores: true (1) y false (0).\njulia> typeof(true)\nBool\n\njulia> typeof(false)\nBool\n\njulia> typeof(1 < 2)\nBool\n\njulia> true + true\n2"
  },
  {
    "objectID": "tipos-datos.html#variables",
    "href": "tipos-datos.html#variables",
    "title": "2  Tipos de datos y variables",
    "section": "2.8 Variables",
    "text": "2.8 Variables\nComo lenguaje de tipado dinámico, no es necesario declarar una variable antes de usarla. Su tipo se infiere directamente del valor asociado.\njulia> x = 1\n1\n\njulia> typeof(x)\nInt64\n\njulia> x = \"julia\"\n\"julia\"\n\njulia> typeof(x)\nString\nNo obstante, para variables de ámbito local, por ejemplo en funciones, es posible fijar el tipo de una variable indicándolo detrás de su nombre con el operador ::.\nx::Int64"
  },
  {
    "objectID": "tipos-datos.html#nombres-de-variables",
    "href": "tipos-datos.html#nombres-de-variables",
    "title": "2  Tipos de datos y variables",
    "section": "2.9 Nombres de variables",
    "text": "2.9 Nombres de variables\nJulia reconoce la codificación Unicode (UTF-8), lo que permite utilizar caracteres con tildes, letras griegas, símbolos matemáticos y hasta emoticonos en los nombres de variables o funciones. Para ello se utilizan códigos especiales (en muchos casos son los mismos que en LaTeX), pulsando después la tecla de tabulación.\njulia> α = 1\n1\n\njulia> β = 2\n2\n\njulia> α + β\n3\n\njulia> 😄 = \"julia\"\n\"julia\"\nDistingue entre mayúsculas y minúsculas.\n\n2.9.1 Caracteres Unicode\nLa siguiente tabla contiene algunos caracteres Unicode habituales\n\n\n\n\n\n\n\n\nCódigo\nSímbolo\nUso notes\n\n\n\n\n\\euler\nℯ\nConstante de Euler e\n\n\n\\pi\nπ\nConstante \\(pi\\)\n\n\n\\alpha\nα\n\n\n\n\\beta\nβ\n\n\n\n\\delta\nδ\n\n\n\n\\Delta\nΔ\nVariación\n\n\n\\gamma\nγ\n\n\n\n\\phi\nϕ\n\n\n\n\\Phi\nΦ\n\n\n\nx\\_1\nx₁\nSubíndices\n\n\nx\\^2\nx²\nSuperíndices\n\n\nr\\vec\nr⃗\nNotación para vectores\n\n\nT\\hat\nT̂\nNotación para vectores unitarios\n\n\n\\partial\n∂\nNotación para derivadas parciales\n\n\n\\nabla\n∇\nNotación para el gradiente\n\n\n\\circ\n∘\nOperador de composición\n\n\n\\cdot\n⋅\nOperador de producto escalar\n\n\n\\times\n×\nOperador de producto vectorial\n\n\n\nLos operadores pueden necesitar paréntesis, como por ejemplo (f ∘ g)(x) para la composición de g con f."
  },
  {
    "objectID": "tipos-datos.html#operadores-aritméticos",
    "href": "tipos-datos.html#operadores-aritméticos",
    "title": "2  Tipos de datos y variables",
    "section": "2.10 Operadores aritméticos",
    "text": "2.10 Operadores aritméticos\n\n\n\nOperador\nDescripción\n\n\n\n\nx + y\nSuma\n\n\nx - y\nResta\n\n\nx * y\nProducto\n\n\nx / y\nDivisión\n\n\nx ÷ y\nCociente división entera\n\n\nx % y\nResto división entera\n\n\nx ^ y\nPotencia"
  },
  {
    "objectID": "tipos-datos.html#operadores-de-comparación",
    "href": "tipos-datos.html#operadores-de-comparación",
    "title": "2  Tipos de datos y variables",
    "section": "2.11 Operadores de comparación",
    "text": "2.11 Operadores de comparación\n\n\n\nOperador\nDescripción\n\n\n\n\n==\nIgualdad\n\n\n!=, ≠\nDesigualdad\n\n\n<\nMenor que\n\n\n<=, ≤\nMenor o igual que\n\n\n>\nMayor que\n\n\n>=, ≥\nMayor o igual que"
  },
  {
    "objectID": "tipos-datos.html#operadores-booleanos",
    "href": "tipos-datos.html#operadores-booleanos",
    "title": "2  Tipos de datos y variables",
    "section": "2.12 Operadores booleanos",
    "text": "2.12 Operadores booleanos\n\n\n\nOperador\nDescripción\n\n\n\n\n!x\nNegación\n\n\nx && y\nConjunción (y)\n\n\nx || y\nDisyunción (o)"
  },
  {
    "objectID": "tipos-datos.html#funciones-numéricas-predefinidas",
    "href": "tipos-datos.html#funciones-numéricas-predefinidas",
    "title": "2  Tipos de datos y variables",
    "section": "2.13 Funciones numéricas predefinidas",
    "text": "2.13 Funciones numéricas predefinidas\n\n2.13.1 Funciones de redondeo\n\n\n\n\n\n\n\nFunción\nDescripción\n\n\n\n\nround(x)\nDevuelve el entero más próximo a x\n\n\nround(x, digits = n)\nDevuelve al valor más próximo a x con n decimales\n\n\nfloor(x)\nRedondea x al próximo entero menor\n\n\nceil(x)\nRedondea x al próximo entero mayor\n\n\ntrunc(x)\nDevuelve la parte entera de x\n\n\n\n\n\n2.13.2 Ejemplo de funciones de redondeo\njulia> round(2.7)\n3.0\n\njulia> floor(2.7)\n2.0\n\njulia> floor(-2.7)\n-3.0\n\njulia> ceil(2.7)\n3.0\n\njulia> ceil(-2.7)\n-2.0\n\njulia> trunc(2.7)\n2.0\n\njulia> trunc(-2.7)\n-2.0\n\njulia> round(2.5)\n2.0\n\njulia> round(2.786, digits = 2)\n2.79\n\n\n2.13.3 Funciones de división\n\n\n\n\n\n\n\nFunción\nDescripción\n\n\n\n\ndiv(x,y), x÷y\nCociente de la división entera\n\n\nfld(x,y)\nCociente de la división entera redondeado hacia abajo\n\n\ncld(x,y)\nCociente de la división entera redondeado hacia arriba\n\n\nrem(x,y), x%y\nResto de la división entera. Se cumple x == div(x,y)*y + rem(x,y)\n\n\nmod(x,y)\nMódulo con respecto a y. Se cumple x == fld(x,y)*y + mod(x,y)\n\n\ngcd(x,y...)\nMáximo común divisor positivo de x, y,…\n\n\nlcm(x,y...)\nMínimo común múltiplo positivo de x, y,…\n\n\n\n\n\n2.13.4 Ejemplo de funciones de división\njulia> div(5,3)\n1\n\njulia> cld(5,3)\n2\n\njulia> 5%3\n2\n\njulia> -5%3\n-2\n\njulia> mod(5,3)\n2\n\njulia> mod(-5,3)\n1\n\njulia> gcd(12,18)\n6\n\njulia> lcm(12,18)\n36\n\n\n2.13.5 Funciones para el signo y el valor absoluto\n\n\n\n\n\n\n\nFunción\nDescripción\n\n\n\n\nabs(x)\nValor absoluto de x\n\n\nsign(x)\nDevuelve 1 si x es positivo, -1 si es negativo y 0 si es 0.\n\n\n\njulia> abs(2.5)\n2.5\n\njulia> abs(-2.5)\n2.5\n\njulia> sign(-2.5)\n-1.0\n\njulia> sign(0)\n0\n\njulia> sign(2.5)\n1.0\n\n\n2.13.6 Raíces, exponenciales y logaritmos\n\n\n\n\n\n\n\nFunción\nDescripción\n\n\n\n\nsqrt(x), √x\nRaíz cuadrada de x\n\n\ncbrt(x), ∛x\nRaíz cúbica de x\n\n\nexp(x)\nExponencial de x\n\n\nlog(x)\nLogaritmo neperiano de x\n\n\nlog(b,x)\nLogaritmo en base b de x\n\n\nlog2(x)\nLogaritmo en base 2 de x\n\n\nlog10(x)\nLogaritmo en base 10 de x\n\n\n\n\n\n2.13.7 Ejemplo de raíces, exponenciales y logaritmos\njulia> sqrt(4)\n2.0\n\njulia> cbrt(27)\n3.0\n\njulia> exp(1)\n2.718281828459045\n\njulia> exp(-Inf)\n0.0\n\njulia> log(1)\n0.0\n\njulia> log(0)\n-Inf\n\njulia> log(-1)\nERROR: DomainError with -1.0:\nlog will only return a complex result if called with a complex argument.\n...\n\njulia> log(-1+0im)\n0.0 + 3.141592653589793im\n\njulia> log2(2^3)\n3.0\n\n\n2.13.8 Funciones trigonométricas\n\n\n\n\n\n\n\nFunción\nDescripción\n\n\n\n\nhypot(x,y)\nHipotenusa del triángulo rectángulo con catetos x e y\n\n\nsin(x)\nSeno del ángulo x en radianes\n\n\nsind(x)\nSeno del ángulo x en grados\n\n\ncos(x)\nCoseno del ángulo x en radianes\n\n\ncosd(x)\nCoseno del ángulo x en grados\n\n\ntan(x)\nTangente del ángulo x en radianes\n\n\ntand(x)\nTangente del ángulo x en grados\n\n\nsec(x)\nSecante del ángulo x en radianes\n\n\ncsc(x)\nCosecante del ángulo x en radianes\n\n\ncot(x)\nCotangente del ángulo x en radianes\n\n\n\n\n\n2.13.9 Ejemplo de funciones trigonométricas\njulia> sin(π/2)\n1.0\n\njulia> cos(π/2)\n6.123233995736766e-17\n\njulia> cosd(90)\n0.0\n\njulia> tan(π/4)\n0.9999999999999999\n\njulia> tand(45)\n1.0\n\njulia> tan(π/2)\n1.633123935319537e16\n\njulia> tand(90)\nInf\n\njulia> sin(π/4)^2 + cos(π/4)^2\n1.0\n\n\n2.13.10 Funciones trigonométricas inversas\n\n\n\n\n\n\n\nFunción\nDescripción\n\n\n\n\nasin(x)\nArcoseno (inversa del seno) de x en radianes\n\n\nasind(x)\nArcoseno (inversa del seno) de x en grados\n\n\nacos(x)\nArcocoseno (inversa del coseno) de x en radianes\n\n\nacosd(x)\nArcocoseno (inversa del coseno) de x en grados\n\n\natan(x)\nArcotangente (inversa de la tangente) de x en radianes\n\n\natand(x)\nArcotangente (inversa de la tangente) de x en grados\n\n\nasec(x)\nArcosecante (inversa de la secante) de x en radianes\n\n\nacsc(x)\nArcocosecante (inversa de la cosecante) de x en radianes\n\n\nacot(x)\nArcocotangente (inversa de la cotangente) de x en radianes\n\n\n\n\n\n2.13.11 Ejemplo de funciones trigonométricas inversas\njulia> asin(1)\n1.5707963267948966\n\njulia> asind(1)\n90.0\n\njulia> acos(-1)\n3.141592653589793\n\njulia> atan(1)\n0.7853981633974483\n\njulia> atand(tan(π/4))\n45.0"
  },
  {
    "objectID": "tipos-datos.html#precedencia-de-operadores",
    "href": "tipos-datos.html#precedencia-de-operadores",
    "title": "2  Tipos de datos y variables",
    "section": "2.14 Precedencia de operadores",
    "text": "2.14 Precedencia de operadores\nDe mayor a menor prioridad.\n\n\n\n\n\n\n\n\nCategoría\nOperadores\nAsociatividad\n\n\n\n\nExponenciación\n^\nDerecha\n\n\nUnarios\n+ - √\nDerecha\n\n\nFracciones\n//\nIzquierda\n\n\nMultiplicación\n* / % & \\ ÷\nIzquierda\n\n\nAdición\n+ - |\nIzquierda\n\n\nComparaciones\n> < >= <= == != !==\n\n\n\nAsignaciones\n= += -= *= /= //= ^= ÷= %= |= &=\nDerecha"
  },
  {
    "objectID": "tipos-datos.html#operaciones-con-cadenas",
    "href": "tipos-datos.html#operaciones-con-cadenas",
    "title": "2  Tipos de datos y variables",
    "section": "2.15 Operaciones con cadenas",
    "text": "2.15 Operaciones con cadenas\nLas cadenas son secuencias de caracteres alfanuméricos del tipo char entre dobles comillas.\nCada carácter tiene asociado un índice entero. El primer carácter de la cadena tiene índice 1.\n\n\n\nÍndice\n1\n2\n3\n4\n5\n\n\nCadena\nj\nu\nl\ni\na\n\n\n\nPodemos acceder a cada carácter usando su índice entre corchetes a continuación de la cadena:\n\ns[i]: Devuelve el carácter con índice i en la cadena s.\n\njulia> c = \"julia\"\n\"julia\"\n\njulia> c[2]\n'u': ASCII/Unicode U+0075 (category Ll: Letter, lowercase)\n\n2.15.1 Acceso a caracteres Unicode\nSin embargo, como Julia permite caracteres Unicode, el índice de un carácter en una cadena, no siempre se corresponde con su posición en la cadena. Ello es debido a que la codificación UTF-8 no utiliza el mismo número de bytes para representar los caracteres Unicode. Mientras que los caracteres habituales del código ASCII (letras romanas y números árabes) solo necesitan un byte, otros caracteres como los símbolos matemáticos requieren más.\n\n\n\nÍndice\n1\n4\n5\n6\n9\n\n\nCadena\n∀\nx\n\n∃\ny\n\n\n\n\n\n2.15.2 Ejemplo de acceso a caracteres Unicode\njulia> c = \"∀x ∃y\"\n\"∀x ∃y\"\n\njulia> c[1]\n'∀': Unicode U+2200 (category Sm: Symbol, math)\n\njulia> c[2]\nERROR: StringIndexError: invalid index [2], \nvalid nearby indices [1]=>'∀', [4]=>'x'\nStacktrace:\n [1] string_index_err(s::String, i::Int64)\n   @ Base ./strings/string.jl:12\n [2] getindex_continued(s::String, i::Int64, u::UInt32)\n   @ Base ./strings/string.jl:233\n [3] getindex(s::String, i::Int64)\n   @ Base ./strings/string.jl:226\n [4] top-level scope\n   @ REPL[128]:1\n\n\n2.15.3 Acceso a índices en cadenas\nLas siguientes funciones permiten acceder a los índices de una cadena:\n\nfirstindex(c): Devuelve el índice del primer carácter de la cadena c.\nlastindex(c): Devuelve el índice del primer carácter de la cadena c.\nnextind(c, i): Devuelve el índice del carácter de la cadena c que sigue al carácter con índice i.\nprevind(c, i): Devuelve el índice del carácter de la cadena c que sigue al carácter con índice i.\n\n\n\n2.15.4 Ejemplo de acceso a índices en cadenas\njulia> firstindex(c)\n1\n\njulia> lastindex(c)\n9\n\njulia> c[9]\n'y': ASCII/Unicode U+0079 (category Ll: Letter, lowercase)\n\njulia> nextind(c,1)\n4\n\njulia> prevind(c, lastindex(c))\n6\n\n\n2.15.5 Subcadenas\nPara obtener subcadenas se usan también los corchetes indicando los índices de inicio y fin separados por :.\n\ns[i:j]: Devuelve la subcadena que va desde el índice i al índice j, ambos incluidos.\n\nTambién se pueden obtener subcadenas con la siguiente función:\n\nSubString(s, i, j): Devuelve la subcadena que va desde el índice i al índice j, ambos incluidos.\n\njulia> c = \"julia\"\n\"julia\"\n\njulia> c[2:4]\n\"uli\"\n\njulia> SubString(c, 2, 4)\n\"uli\""
  },
  {
    "objectID": "tipos-datos.html#concatenación-de-cadenas",
    "href": "tipos-datos.html#concatenación-de-cadenas",
    "title": "2  Tipos de datos y variables",
    "section": "2.16 Concatenación de cadenas",
    "text": "2.16 Concatenación de cadenas\n\na * b: Devuelve la cadena que resulta de concatenar las cadenas a y b.\na ^ i: Devuelve la cadena que resulta de repetir la cadena a el número de veces i.\nrepeat(a, i): Devuelve la cadena que resulta de repetir la cadena a el número de veces i.\n\njulia> a = \"Hola\"\n\"Hola\"\n\njulia> b = \"Julia\"\n\"Julia\"\n\njulia> a * b\n\"HolaJulia\"\n\njulia> b ^ 3\n\"JuliaJuliaJulia\"\n\n2.16.1 Interpolación de cadenas\nEn una cadena se pueden introducir variables o expresiones precedidas del símbolo $, de manera que al evaluarlas julia sustituye la variable o expresión por su valor. Esto es muy util para formatear salidas.\njulia> \"1 + 2 = $(1 + 2)\"\n\"1 + 2 = 3\"\n\njulia> s = \"Julia\"\n\"Julia\"\n\njulia> \"Hola $s\"\n\"Hola Julia\"\n\n\n2.16.2 Otras operaciones comunes con cadenas\n\nlength(c): Devuelve el número de caracteres de la cadena c.\nfindfirst(a, c): Devuelve el índice de la primera ocurrencia de la cadena a en la cadena c. Si a no es una subcadena de c devuelve nada (tipo Nothing).\nfindlast(a, c): Devuelve el índice de la última ocurrencia de la cadena a en la cadena c. Si a no es una subcadena de c devuelve nada (tipo Nothing).\nfindnext(a, c, i): Devuelve el índice de la primera ocurrencia de la cadena a en la cadena c posterior al índice i.\nfindprev(a, c, i): Devuelve el índice de la última ocurrencia de la cadena a en la cadena c anterior al índice i.\n\n\n\n2.16.3 Otras operaciones comunes con cadenas\n\noccursin(a, c): Devuelve true si la cadena a es una subcadena de c, y false en caso contrario.\ncontains(c, a): Devuelve true si la cadena a es una subcadena de c, y false en caso contrario.\nreplace(c, a => b): Devuelve la cadena que resulta de sustituir la cadena a por la b en la cadena c.\nlowercase(c): Devuelve la cadena c en minúsculas.\nuppercase(c): Devuelve la cadena c en mayúsculas.\nprefix(c, a): Devuelve true si la cadena a es un prefijo de la cadena c.\nsuffix(c, a): Devuelve true si la cadena a es un sufijo de la cadena c.\nsplit(c, a): Devuelve una lista con las cadenas que resulpan de partir la cadena c por el delimitador a.\n\n\n\n2.16.4 Ejemplo de otras operaciones con cadenas\njulia> c = \"Hola Julia\"\n\"Hola Julia\"\n\njulia> length(c)\n10\n\njulia> findfirst(\"a\", c) \n4:4\n\njulia> findlast(\"Ju\", c)\n6:7\n\njulia> findlast(\"x\", c)\n\njulia> occursin(\"Julia\", c)\ntrue\n\njulia> occursin(\"julia\", c)\nfalse\n\njulia> replace(c, \"a\" => \"o\")\n\"Holo Julio\"\n\njulia> uppercase(c)\n\"HOLA JULIA\"\n\njulia> split(c, \" \")\n2-element Vector{SubString{String}}:\n \"Hola\"\n \"Julia\""
  },
  {
    "objectID": "tipos-datos.html#entrada-y-salida-por-terminal",
    "href": "tipos-datos.html#entrada-y-salida-por-terminal",
    "title": "2  Tipos de datos y variables",
    "section": "2.17 Entrada y salida por terminal",
    "text": "2.17 Entrada y salida por terminal\nLas siguientes funciones muestran una cadena en la terminal:\n\nprint(c): Muestra por la terminal la cadena c sin cambiar de línea.\nprintln(c): Muestra por la terminal la cadena c y cambia de línea.\n\nLa siguiente función permite leer una línea de texto desde la terminal:\n\nreadline(): Devuelve en una cadena una línea de texto introducida por el usuario en la terminal (hasta el carácter de cambio de línea \\n)\n\njulia> print(\"¿Cómo te llamas?\")\n¿Cómo te llamas?\njulia> nombre = readline()\nAlf            \n\"Alf\"\n\njulia> println(\"Hola $nombre\")\nHola Alf\n\n2.17.1 Conversión de cadenas en números\nLa función readline() siempre devuelve una cadena aún cuando se pregunte al usuario por un valor numérico. Para convertir una cadena en un dato numérico se utiliza la siguiente función:\n\nparse(tipo, c): Covierte la cadena c a un número del tipo numérico tipo, siempre que puedad realizarse la conversión.\n\njulia> print(\"Introduce tu edad\")\nIntroduce tu edad\njulia> edad = parse(Int, readline())\n18\n18\n\njulia> println(\"Vas a cumplir $(edad + 1) años\")\nVas a cumplir 19 años\n\njulia> typeof(edad)\nInt64"
  },
  {
    "objectID": "estructuras-control.html",
    "href": "estructuras-control.html",
    "title": "3  Estructuras de control",
    "section": "",
    "text": "if condición 1\n   bloque código 1\nelseif condición 2\n   bloque código 2\n…\nelse\n   bloque código n\nend\n\nLa indentación de los bloques de código no es necesaria, pero es una buena práctica.\n\n\njulia> x = -1\n-1\n\njulia> if x > 0\n         signo = \"positivo\"\n       elseif x < 0\n         signo = \"negativo\"\n       else\n         signo = \"nulo\"\n       end\n\"negativo\"\n\n\n\nUna forma abreviada de la estructura condicional es el operador condicional.\n\ncondición ? bloque true : bloque false\n\nEste operador ejecuta el primer bloque de código si la condición es true y el segundo en caso contrario.\njulia> x > 0 ? signo = \"positivo\" : signo = \"negativo\"\n\"negativo\""
  },
  {
    "objectID": "estructuras-control.html#bucles",
    "href": "estructuras-control.html#bucles",
    "title": "3  Estructuras de control",
    "section": "3.2 Bucles",
    "text": "3.2 Bucles"
  },
  {
    "objectID": "estructuras-control.html#bucles-iterativos",
    "href": "estructuras-control.html#bucles-iterativos",
    "title": "3  Estructuras de control",
    "section": "3.3 Bucles iterativos",
    "text": "3.3 Bucles iterativos\n\nfor iterador in secuencia\n   bloque código\nend\n\nEjecuta el bloque de código tantas veces como elementos tenga la secuencia. En cada iteración el iterador toma como valor el siguiente elemento de la secuencia.\njulia> c = \"Julia\"\n\"Julia\"\n\njulia> for i in c\n         println(i)\n       end\nJ\nu\nl\ni\na\n\n3.3.1 Bucles iterativos con rangos\nEn muchas ocasiones la secuencia que se recorre en un bucle iterativo se genera mediante un rango, que es una secuencia de números igualmente espaciados. Existen distintas funciones para generar rangos:\n\ni:j: Genera la secuenciad de números desde i hasta j.\ni:j:k: Genera la secuencia de números desde i hasta k dando saltos de j.\nStepRange(i, j, k): Genera la secuencia de números desde i hasta k dando saltos de j.\nrange(i, j, n): Genera una secuencia de n números desde i hasta j.\n\n\n\n3.3.2 Ejemplo de bucles iterativos con rangos\njulia> for i in 1:2:10\n         println(i)\n       end\n1\n3\n5\n7\n9\n\njulia> for i = range(0, 10, 5)\n         println(i)\n       end\n0.0\n2.5\n5.0\n7.5\n10.0\n\n\n3.3.3 Bucles iterativos anidados\nEn muchas ocasiones es habitual incluir un bucle iterativo en el bloque de código de otro bucle iterativo, lo que se conoce como bucles anidados.\nJulia permite simplificar estas estructuras indicando los iteradores en la cabecera de un único bucle.\njulia> for i in \"abc\", j = 1:2\n         println(i,j)\n       end\na1\na2\nb1\nb2\nc1\nc2"
  },
  {
    "objectID": "estructuras-control.html#bucles-condicionales",
    "href": "estructuras-control.html#bucles-condicionales",
    "title": "3  Estructuras de control",
    "section": "3.4 Bucles condicionales",
    "text": "3.4 Bucles condicionales\n\nwhile condición\n   bloque código\nend\n\nRepite la ejecución del bloque de código mientras que la condición sea cierta.\njulia> x = 3\n3\n\njulia> while x >= 0\n          println(x)\n          x -= 1\n       end\n3\n2\n1\n0\n\n3.4.1 Interrupción de bucles\nLa instrucción break provoca inmediatamente la finalización de un bucle tanto iterativo como condicional.\njulia> x=3\n3\n\njulia> while true\n          if x < 0 \n             break\n          end\n          println(x)\n          x -= 1\n       end\n3\n2\n1\n0\n\n\n3.4.2 Salto de bucles\nLa instrucción continue provoca la finalización del bloque de código de un bucle y pasa inmediatamente a la siguiente iteración.\njulia> for i in 1:10\n          if i % 2 == 0\n             continue\n          end\n          println(i)\n       end\n1\n3\n5\n7\n9"
  },
  {
    "objectID": "tipos-datos-compuestos.html",
    "href": "tipos-datos-compuestos.html",
    "title": "4  Tipos de datos compuestos",
    "section": "",
    "text": "Colecciones de datos con distinta estructura y semántica.\n\nArrays\n\nVectores\nMatrices\n\nTuplas\nDiccionarios\nConjuntos"
  },
  {
    "objectID": "tipos-datos-compuestos.html#arrays",
    "href": "tipos-datos-compuestos.html#arrays",
    "title": "4  Tipos de datos compuestos",
    "section": "4.2 Arrays",
    "text": "4.2 Arrays\nUn array es una colección ordenada de datos de un mismo tipo.\nEl tipo del array se infiere automáticamente a partir de los tipos de sus elementos. Si los elementos son de distintos tipos se convierten al tipo más específico de la jerarquía de tipos del que los tipos de los elementos son subtipos.\nSe construyen escribiendo sus elementos separados por comas, puntos y comas o espacios entre corchetes.\njulia> [1, 2, 3]\n3-element Vector{Int64}:\n 1\n 2\n 3\n\njulia> [1.0, \"julia\", true]\n3-element Vector{Any}:\n    1.0\n     \"julia\"\n true"
  },
  {
    "objectID": "tipos-datos-compuestos.html#arrays-multidimensionales",
    "href": "tipos-datos-compuestos.html#arrays-multidimensionales",
    "title": "4  Tipos de datos compuestos",
    "section": "4.3 Arrays multidimensionales",
    "text": "4.3 Arrays multidimensionales\nLos arrays pueden estructurar sus elementos en múltiples dimensiones. Dependiendo el número de dimensiones tenemos distintos tipos de arrays:\n\n\n4.3.1 Funciones de arrays\n\nlength(A): Devuelve el número de elementos del array A.\neltype(A): Devuelve el tipo de los elementos del array A.\nndims(A): Devuelve el número de dimensiones del array A.\nsize(A): Devuelve una tupla con los tamaños de las dimensiones del array A.\nsize(A, n): Devuelve el tamaño de la dimensión n del array A.\naxes(A): Devuelve una tupla con los índices válidos de cada dimensión del array A.\naxes(A, n): Devuelve un rango con los índices válidos de la dimensión n del array A.\neachindex(A): Devuelve un iterador sobre los índices de los elementos del array A.\n\n\n\n4.3.2 Constructores de arrays\n\nzeros(dim): Devuelve un array de la dimensiones indicadas por la tupla dim con todos sus elementos ceros.\nones(dim): Devuelve un array de la dimensiones indicadas por la tupla dim con todos sus elementos unos.\nfill(a, dim): Devuelve un array de la dimensiones indicadas por la tupla dim con todos sus elementos iguales a.\nrand(dim): Devuelve un array de la dimensiones indicadas por la tupla dim con todos sus elementos números aleatorios entre 0 y 1.\ntrues(dim): Devuelve un array de la dimensiones indicadas por la tupla dim con todos sus elementos true.\nfalses(dim): Devuelve un array de la dimensiones indicadas por la tupla dim con todos sus elementos false.\n\n\n\n4.3.3 Ejemplos de constructores de arrays\njulia> zeros(3)  # Vector de tamaño 3\n3-element Vector{Float64}:\n 0.0\n 0.0\n 0.0\n\njulia> rand(3,2)  # Matriz de tamaño 3 x 2\n3×2 Matrix{Float64}:\n 0.1469    0.891839\n 0.953462  0.395681\n 0.819468  0.720606\n\njulia> fill(π, 2, 2)\n2×2 Matrix{Irrational{:π}}:\n π  π\n π  π\n\n\n4.3.4 Redimensionamiento de arrays\nLa siguientes funciones permiten cambiar las dimensiones de un array, reestructurando sus elementos:\n\nreshape(A, dim): Devuelve el array que resulta de redimiensionar el array A con las dimensiones indicadas por la tupla dim.\npermutedims(A): Devuelve el array de resulta de trasponer el array A.\n\n\n\n\n\n\n\nAdvertencia\n\n\n\nEl array resultante debe tener los mismos elementos que el array original, por lo que si las dimensiones no son compatibles se produce un error.\n\n\n\n\n4.3.5 Ejemplo de redimensionamiento de arrays\njulia> v = [1, 2, 3, 4, 5, 6]\n6-element Vector{Int64}:\n 1\n 2\n 3\n 4\n 5\n 6\n\njulia> reshape(v, 2, 3)\n2×3 Matrix{Int64}:\n 1  3  5\n 2  4  6\n\njulia> reshape(v, 3, 2)\n3×2 Matrix{Int64}:\n 1  4\n 2  5\n 3  6\n\njulia> permutedims(reshape(v, 3, 2))\n2×3 Matrix{Int64}:\n 1  2  3\n 4  5  6\n\n\n4.3.6 Comprensión de arrays\nUna potente técnica de creación de arrays es la comprensión de arrays, que consiste en generar los elementos del array a partir de uno o varios iteradores.\n\n[exp for i = ite]: Devuelve el vector cuyos elementos resultan de evaluar a expresión exp para cada valor i del iterador ite.\n[exp for i = ite if cond]: Devuelve el vector cuyos elementos resultan de evaluar a expresión exp para cada valor i del iterador ite que cumpla la condición cond.\n\nSe pueden utilizar varios iteradores para crear arrays de varias dimensiones.\njulia> [i^2 for i = 1:4]\n4-element Vector{Int64}:\n  1\n  4\n  9\n 16\n\njulia> [i^2 for i = 1:4 if i % 2 == 0]\n2-element Vector{Int64}:\n  4\n 16\n\njulia> [i+j for i = 1:2, j = 3:4]\n2×2 Matrix{Int64}:\n 4  5\n 5  6"
  },
  {
    "objectID": "tipos-datos-compuestos.html#vectores",
    "href": "tipos-datos-compuestos.html#vectores",
    "title": "4  Tipos de datos compuestos",
    "section": "4.4 Vectores",
    "text": "4.4 Vectores\nLos vectores son arrays de una dimensión.\nSe construyen escribiendo sus elementos separados por comas o puntos y comas entre corchetes.\njulia> v = [1, 2, 3]\n3-element Vector{Int64}:\n 1\n 2\n 3\n\njulia> length(v)\n3\n\njulia> eltype(v)\nInt64\n\njulia> ndims(v)\n1\n\njulia> size(v)\n(3,)\n\njulia> eachindex(v)\nBase.OneTo(3)\n\n4.4.1 Acceso a los elementos de un vector\nEl acceso a los elementos de un vector es mediante índices. Cada elemento del vector tiene asociado un índice entero que se corresponde con su posición desde 1 hasta el número de elementos.\n\nv[i]: Devuelve el elemento del vector v con índice i.\n\n\n\n\n\n\n\nAdvertencia\n\n\n\nSi se proporciona un índice no válido se produce un error.\n\n\nLas palabras reservadas begin y end se utilizan para referirse al primer y último índice de un vector.\n\n\n4.4.2 Ejemplo de acceso a los elementos de un vector\njulia> v = [2, 4, 6]\n3-element Vector{Int64}:\n 2\n 4\n 6\n\njulia> v[2]\n4\n\njulia> v[end]\n6\n\njulia> v[4]\nERROR: BoundsError: attempt to access 3-element Vector{Int64} at index [4]\nStacktrace:\n [1] getindex(A::Vector{Int64}, i1::Int64)\n   @ Base ./array.jl:861\n [2] top-level scope\n   @ REPL[4]:1\n\n\n4.4.3 Acceso a múltiples elementos de un vector\nEs posible extraer varios elementos de un vector a la vez indicando los índices mediante un rango o un vector de enteros.\n\nv[i:j]: Devuelve un vector con los elementos del vector v desde el índice i al j.\nv[u]: Devuelve un vector con los elementos del vector v correspondientes a los índices del vector u.\n\njulia> v = [2, 4, 6, 8];\n\njulia> v[2:3]\n2-element Vector{Int64}:\n 4\n 6\n\njulia> v[[2,4,3]]\n3-element Vector{Int64}:\n 4\n 8\n 6\n\n\n4.4.4 Modificación de los elementos de un vector\nTambién es posible modificar un vector asignando nuevos elementos mediante los índices.\n\nv[i] = a: Añade el elemento a al vector v en el índice i.\n\njulia> v = [2, 4, 6]\n3-element Vector{Int64}:\n 2\n 4\n 6\n\njulia> v[2] = 0\n0\n\njulia> v\n3-element Vector{Int64}:\n 2\n 0\n 6\n\n\n4.4.5 Añadir elementos a un vector\nLas siguientes funciones permiten añadir elementos al final de un vector:\n\npush!(v, a): Añade el elemento a al final del vector v.\nappend!(v, u): Añade los elementos del vector u al final del vector v.\n\njulia> v = [];\n\njulia> push!(v, 1)\n1-element Vector{Any}:\n 1\n\njulia> append!(v, [2, 3])\n3-element Vector{Any}:\n 1\n 2\n 3\n\njulia> v\n3-element Vector{Any}:\n 1\n 2\n 3\n\n\n4.4.6 Recorrer un vector\nUna operación habitual es recorrer los elementos de un vector para hacer cualquier operación con ellos. Existen dos posibilidades: recorrer el vector por índice o por valor.\njulia> v = [2, 4, 6];\n\njulia> for i in v  # Recorrido por valor\n         println(i)\n       end\n2\n4\n6\n\njulia> for i in eachindex(v)  # Recorrido por índice\n         println(v[i])\n       end\n2\n4\n6\n\n\n4.4.7 Operaciones con vectores numéricos\n\nminimum(v): Devuelve el menor elemento del vector v.\nmaximum(v): Devuelve el mayor elemento del vector v.\nargmin(v): Devuelve el índice del menor elemento del vector v.\nargmax(v): Devuelve el índice del mayor elemento del vector v.\nsum(v): Devuelve la suma de los elementos del vector v.\nprod(v): Devuelve el producto de los elementos del vector v.\nunique(v): Devuelve un vector con los elementos de v sin repetir.\n\njulia> v = [4, 2, 3];\n\njulia> maximum(v)\n4\n\njulia> argmax(v)\n1\n\njulia> sum(v)\n9\n\njulia> prod(v)\n24\n\n\n4.4.8 Ordenación de vectores\n\nsort(v, rev=true): Devuelve el vector que resulta de ordenar en orden ascendente los elementos del vector v. Si se pasa true al parámetro rev el orden es descendente.\nsort!(v, rev=true): Ordena el vector v en orden ascendente. Si se pasa true al parámetro rev el orden es descendente.\nreverse(v): Devuelve el vector con los elementos del vector v en orden inverso.\nreverse!(v): Modifica el vector v poniendo sus elementos en orden inverso.\n\n\n\n4.4.9 Ejemplo de ordenación de vectores\njulia> v = [4, 2, 3];\n\njulia> sort(v)\n3-element Vector{Int64}:\n 2\n 3\n 4\n\njulia> reverse(v)\n3-element Vector{Int64}:\n 3\n 2\n 4\n\njulia> v\n3-element Vector{Int64}:\n 4\n 2\n 3\n\njulia> reverse!(v)\n3-element Vector{Int64}:\n 3\n 2\n 4\n\njulia> v\n3-element Vector{Int64}:\n 3\n 2\n 4\n\n\n4.4.10 Extensión de funciones a vectores\nSi una función recibe un parámetro del tipo de los elementos de un vector, se puede aplicar la función a cada uno de los elementos del vector, extendiendo la llamada de la función sobre los elementos del vector. Para ello basta con añadir un punto entre el nombre de la función y el paréntesis de los argumentos.\n\nf.(v): Devuelve el vector que resulta de aplicar la función f a cada uno de los elementos del vector v.\n\n\n\n\n\n\n\nAdvertencia\n\n\n\nEn la llamada a la función hay que pasarle com argumentos tantos vectores como parámetros tenga la función. Si los vectores son de distinto tamaño, se reciclan los de menor tamaño.\n\n\n\n\n\n\n\n\nAdvertencia\n\n\n\nSi la función no devuelve ningún valor el resultado es un vector de valores nothing.\n\n\nLa extensión de funciones también funciona con operadores, poniendo el punto delante del operador.\n\n\n4.4.11 Ejemplo de extensión de funciones a vectores\njulia> v = [1, 4, 9];\n\njulia> sqrt.(v)\n3-element Vector{Float64}:\n 1.0\n 2.0\n 3.0\n\njulia> v .^ 2\n3-element Vector{Int64}:\n  1\n 16\n 81\n\njulia> base = [2, ℯ, 10];\n\njulia> log.(base, v)\n3-element Vector{Float64}:\n 0.0\n 1.3862943611198906\n 0.9542425094393249\n\n\n4.4.12 Filtrado de vectores\nOtra operación bastante común son los filtros de vectores. Se puede filtrar un vector a partir de un vector de booleanos del mismo tamaño.\n\nv[u]: Devuelve el vector con los elementos que tienen el mismo índice que los valores true del vector booleano u.\n\nEsto permite aplicar filtros a partir de condiciones que devuelvan un vector de booleanos.\n\n\n4.4.13 Ejemplo de filtrado de vectores\njulia> v = [1, 2, 3, 4];\n\njulia> v[[true, false, true, false]]\n2-element Vector{Int64}:\n 1\n 3\n\njulia> v .% 2 .== 0  # Condición\n4-element BitVector:\n 0\n 1\n 0\n 1\n\njulia> v[v .% 2 .== 0]  # Filtro de números pares\n2-element Vector{Int64}:\n 2\n 4\n\n\n4.4.14 Álgebra lineal con vectores\n\nu + v: Devuelve el vector que resulta de la suma de los vetores u y v.\nu - v: Devuelve el vector que resulta de la resta de los vetores u y v.\na * v: De vuelve el vector que resulta de multiplicar el vector v por el escalar a.\nv': Devuelve el vector que resulta de trasponer el vector v. Si v es un vector fila, v' es un vector columna y viceversa.\n\nCon el paquete LinearAlgebra también están disponibles las siguientes funciones:\n\ndot(u, v): Devuelve el producto escalar de los vectores u y v.\nnorm(v): Devuelve la norma (módulo) del vector v.\n\n\n\n4.4.15 Ejemplo de álgebra lineal con vectores\nusing LinearAlgebra\n\njulia> u = [1, 2, 3]; v = [1, 0, 2];\n\njulia> u + v\n3-element Vector{Int64}:\n 2\n 2\n 5\n\njulia> 2u\n3-element Vector{Int64}:\n 2\n 4\n 6\n\njulia> dot(u, v)  # Producto escalar\n7\n\njulia> u'v  # Producto escalar\n7\n\njulia> norm(v)  # Norma o módulo\n2.23606797749979\n\njulia> u / norm(u)  # Vector unitario\n3-element Vector{Float64}:\n 0.2672612419124244\n 0.5345224838248488\n 0.8017837257372732"
  },
  {
    "objectID": "tipos-datos-compuestos.html#matrices",
    "href": "tipos-datos-compuestos.html#matrices",
    "title": "4  Tipos de datos compuestos",
    "section": "4.5 Matrices",
    "text": "4.5 Matrices\nLas matrices son arrays de dos dimensiones (filas x columnas).\nSe construyen escribiendo sus elementos entre corchetes, separando los elementos por espacio y las filas por punto y coma ;.\njulia> A = [1 2 3; 4 5 6]\n2×3 Matrix{Int64}:\n 1  2  3\n 4  5  6\n\njulia> length(A)\n6\n\njulia> eltype(A)\nInt64\n\njulia> ndims(A)\n2\n\njulia> size(A)\n(2, 3)\n\n4.5.1 Acceso a los elementos de una matriz\nEl acceso a los elementos de una matriz es mediante índices. Cada elemento de la matriz tiene asociado un par de índices enteros que se corresponde la fila y la columna que ocupa.\n\nA[i, j]: Devuelve el elemento de la matriz A con índice de fila i e índice de columna j.\n\n\n\n\n\n\n\nAdvertencia\n\n\n\nSi se proporciona algún índice no válido se produce un error.\n\n\nTambién se puede acceder a los elementos de una matriz mediante un único índice. En ese caso se obtiene el elemento con ese índice en el vector que resulta de concatenar los elementos de la matriz por columnas.\n\n\n4.5.2 Ejemplo de acceso a los elementos de una matriz\njulia> A = reshape(1:6, 2, 3)\n2×3 reshape(::UnitRange{Int64}, 2, 3) with eltype Int64:\n 1  3  5\n 2  4  6\n\njulia> A[2, 1]\n2\n\njulia> A[4]\n4\n\n\n4.5.3 Acceso a múltiples elementos de una matriz\nEs posible extraer varios elementos de una matriz a la vez indicando los índices de las filas y las columnas mediante un rango o un vector de enteros.\n\nA[i:j, k:l]: Devuelve una matriz con los elementos desde el índice de fila i al j y el índice de columna k al l de la matriz A.\nA[u, w]: Devuelve una matriz con los elementos correspondientes a los índices de fila del vector u y los índices de columna del vector w de la matriz A."
  },
  {
    "objectID": "tipos-datos-compuestos.html#ejemplo-de-acceso-a-múltiples-elementos-de-una-matriz",
    "href": "tipos-datos-compuestos.html#ejemplo-de-acceso-a-múltiples-elementos-de-una-matriz",
    "title": "4  Tipos de datos compuestos",
    "section": "4.6 Ejemplo de acceso a múltiples elementos de una matriz",
    "text": "4.6 Ejemplo de acceso a múltiples elementos de una matriz\njulia> A = reshape(1:9, 3, :)\n3×3 reshape(::UnitRange{Int64}, 3, 3) with eltype Int64:\n 1  4  7\n 2  5  8\n 3  6  9\n\njulia> A[1:2, 2:3]\n2×2 Matrix{Int64}:\n 4  7\n 5  8\n\njulia> A[[1, 3], [3, 1]]\n2×2 Matrix{Int64}:\n 7  1\n 9  3\n\njulia> A[2, :]  # Segundo vector fila\n3-element Vector{Int64}:\n 2\n 5\n 8\n\n4.6.1 Modificación de los elementos de una matriz\nTambién es posible modificar una matriz asignando nuevos elementos mediante los índices de fila y columna.\n\nA[i, j] = a: Añade el elemento a a la matriz A con el índice de fila i y el índice de columna j.\n\njulia> A = zeros(2, 3)\n2×3 Matrix{Float64}:\n 0.0  0.0  0.0\n 0.0  0.0  0.0\n\njulia> A[2,3] = 1\n1\n\njulia> A\n2×3 Matrix{Float64}:\n 0.0  0.0  0.0\n 0.0  0.0  1.0\n\n\n4.6.2 Concatenación de matrices\nDos o más matrices pueden concatenarse horizontal o verticalmente siempre que sus dimensiones sean compatibles.\n\n[A B]: Devuelve la matriz que resulta de concatenar horizontalmente las matrices A y B. Ambas matrices deben tener el mismo número de filas.\n[A; B]: Devuelve la matriz que resulta de concatenar verticalmente las matrices A y B. Ambas matrices deben tener el mismo número de columnas.\n\n\n\n4.6.3 Ejemplo de concatenación de matrices\njulia> A = zeros(2, 2)\n2×2 Matrix{Float64}:\n 0.0  0.0\n 0.0  0.0\n\njulia> B = ones(2, 1)\n2×1 Matrix{Float64}:\n 1.0\n 1.0\n\njulia> C = ones(1, 3)\n1×3 Matrix{Float64}:\n 1.0  1.0  1.0\n\njulia> D = [A B]\n2×3 Matrix{Float64}:\n 0.0  0.0  1.0\n 0.0  0.0  1.0\n\njulia> [D ; C]\n3×3 Matrix{Float64}:\n 0.0  0.0  1.0\n 0.0  0.0  1.0\n 1.0  1.0  1.0\n\n\n4.6.4 Concatenación de vectores\nTambién es posible concatenar varios vectores horizontalmente o verticalmente para formar una matriz.\n\nhcat(v...): Devuelve la matriz que resulta de concatenar horizontalmente los vectores del vector v.\nvcat(v...): Devuelve la matriz que resulta de concatenar verticalmente los vectores del vector v.\n\n\n\n4.6.5 Ejemplo de concatenación de vectores\njulia> v = [[1, 2, 3], [4, 5, 6]]\n2-element Vector{Vector{Int64}}:\n [1, 2, 3]\n [4, 5, 6]\n\njulia> hcat(v...)\n3×2 Matrix{Int64}:\n 1  4\n 2  5\n 3  6\n\njulia> v = [[1 2 3], [4 5 6]]\n2-element Vector{Matrix{Int64}}:\n [1 2 3]\n [4 5 6]\n\njulia> vcat(v...)\n2×3 Matrix{Int64}:\n 1  2  3\n 4  5  6\n\n\n4.6.6 Recorrido de matrices\nUna operación habitual es recorrer los elementos de una matriz para hacer una operación con ellos. El recorrido se suele hacer con dos bucles iterativos anidados.\njulia> A = [1 2 3; 4 5 6]\n2×3 Matrix{Int64}:\n 1  2  3\n 4  5  6\n\njulia> for i = 1:size(A, 1), j = 1:size(A, 2)  # Recorrido por filas\n         println(A[i, j])\n       end\n1\n2\n3\n4\n5\n6\n\njulia> for j = 1:size(A, 2), i = 1:size(A, 1)  # Recorrido por columnas\n         println(A[i, j])\n       end\n1\n4\n2\n5\n3\n6\n\n\n4.6.7 Operaciones con matrices numéricas\n\nminimum(A): Devuelve el menor elemento de la matriz A.\nmaximum(A): Devuelve el mayor elemento de la matriz A.\nargmin(A): Devuelve los índices de fila y columna del menor elemento de la matriz A.\nargmax(A): Devuelve los índices de fila y columna del mayor elemento de la matriz A.\nsum(A): Devuelve la suma de los elementos de la matriz A.\nprod(A): Devuelve el producto de los elementos de la matriz A.\n\njulia> A = [1 2 3; 4 5 6]\n2×3 Matrix{Int64}:\n 1  2  3\n 4  5  6\n\njulia> minimum(A)\n1\n\njulia> argmax(A)\nCartesianIndex(2, 3)\n\njulia> sum(A)\n21\n\njulia> prod(A)\n720\n\n\n4.6.8 Extensión de funciones a matrices\nAl igual que para vectores, se puede aplicar una una función a todos los elementos de una matriz. Para ello basta con añadir un punto entre el nombre de la función y el paréntesis de los argumentos.\n\nf.(A): Devuelve la matriz que resulta de aplicar la función f a cada uno de los elementos de la matriz A.\n\n\n\n\n\n\n\nAdvertencia\n\n\n\nEn la llamada a la función hay que pasarle como argumentos tantos vectores como parámetros tenga la función. Si las matrices son de distinto tamaño, se reciclan las de menor tamaño.\n\n\nLa extensión de funciones también funciona con operadores, poniendo el punto delante del operador.\n\n\n4.6.9 Ejemplo de extensión de funciones a matrices\njulia> A = [1 2 3; 4 5 6]\n2×3 Matrix{Int64}:\n 1  2  3\n 4  5  6\n\njulia> sqrt.(A)\n2×3 Matrix{Float64}:\n 1.0  1.41421  1.73205\n 2.0  2.23607  2.44949\n\njulia> A .+ 1\n2×3 Matrix{Int64}:\n 2  3  4\n 5  6  7\n\n\n4.6.10 Álgebra lineal con matrices\n\nA + B: Devuelve la matriz que resulta de la suma de las matrices A y B. Ambas matrices deben tener las mismas dimensiones.\nA - B: Devuelve la matriz que resulta de la resta de las matrices A y B. Ambas matrices deben tener las mismas dimensiones.\na * A: Devuelve la matriz que resulta de multiplicar la matriz A por el escalar a.\nA * B: Devuelve la matriz producto de las matrices A y B. El número de columnas de A debe coincidir con el número de filas de B.\nA': Devuelve la matriz traspuesta de la matriz A.\ntranspose(A): Devuelve la matriz traspuesta de la matriz A.\n\n\n\n4.6.11 Ejemplo de álgebra lineal con matrices\njulia> A = [1 2 3; 4 5 6]\n2×3 Matrix{Int64}:\n 1  2  3\n 4  5  6\n\njulia> B = [1 1 1; 2 2 2]\n2×3 Matrix{Int64}:\n 1  1  1\n 2  2  2\n\njulia> A + B\n2×3 Matrix{Int64}:\n 2  3  4\n 6  7  8\n\njulia> C = A'\n3×2 adjoint(::Matrix{Int64}) with eltype Int64:\n 1  4\n 2  5\n 3  6\n\njulia> A * C\n2×2 Matrix{Int64}:\n 14  32\n 32  77\n\njulia> C * A\n3×3 Matrix{Int64}:\n 17  22  27\n 22  29  36\n 27  36  45\n\n\n4.6.12 Álgebra lineal con matrices\nEl paquete LinearAlgebra define las siguientes funciones:\n\nMatrix(I, n, n). Devuelve la matriz identidad de dimensión n.\ndiag(A): Devuelve un vector con los elementos de la diagonal principal de la matriz A.\nnorm(A): Devuelve la norma de Frobenius de la matriz A.\ntr(A): Devuelve la traza de la matriz cuadrada A.\ndet(A): Devuelve el determinante de la matriz cuadrada A.\ninv(A): Devuelve la matriz inversa de la matriz cuadrada A.\nA \\ B: Devuelve el vector x solución del sistema de ecuaciones \\(Ax = B\\), donde A es una matriz cuadrada y B es un vector del mismo tamaño que el número de filas o columnas de A.\n\n\n\n4.6.13 Ejemplo de álgebra lineal con matrices\nusing LinearAlgebra\n\njulia> Matrix(I, 3, 3)\n3×3 Matrix{Bool}:\n 1  0  0\n 0  1  0\n 0  0  1\n\njulia> A = [1 2 3; 0 1 0; 1 0 1]\n3×3 Matrix{Int64}:\n 1  2  3\n 0  1  0\n 1  0  1\n\njulia> diag(A)\n3-element Vector{Int64}:\n 1\n 1\n 1\n\njulia> norm(A)\n4.123105625617661\n\njulia> tr(A)\n3\n\njulia> det(A)\n-2.0\n\njulia> inv(A)\n3×3 Matrix{Float64}:\n -0.5   1.0   1.5\n  0.0   1.0   0.0\n  0.5  -1.0  -0.5\n\njulia> B = [10, 2, 4]\n3-element Vector{Int64}:\n 10\n  2\n  4\n\njulia> A \\ B  # Solución del sistema Ax = B\n3-element Vector{Float64}:\n 3.0\n 2.0\n 1.0\n\n\n4.6.14 Álgebra lineal con matrices\nOtras funciones más avanzadas del paquete LinearAlgebra son:\n\neigvals(A): Devuelve un vector con los autovalores de la matriz A.\neigvecs(A): Devuelve la matriz con los autovectores de la matriz A.\nfactorize(A): Devuelve las matrices resultantes de la factorización de la matriz A. La factorización dependerá de las propiedades de A (ver tipos de factorización)\n\n\n\n4.6.15 Ejemplos de Álgebra lineal con matrices\nusing LinearAlgebra\n\njulia> A = [1 2; 3 1]\n2×2 Matrix{Int64}:\n 1  2\n 3  1\n\njulia> eigvals(A)\n2-element Vector{Float64}:\n -1.4494897427831779\n  3.4494897427831783\n\njulia> eigvecs(A)\n2×2 Matrix{Float64}:\n -0.632456  0.632456\n  0.774597  0.774597\n\njulia> B = [1 2; 2 1]\n2×2 Matrix{Int64}:\n 1  2\n 2  1\n\njulia> factorize(B)\nLU{Float64, Tridiagonal{Float64, Vector{Float64}}}\nL factor:\n2×2 Matrix{Float64}:\n 1.0  0.0\n 0.5  1.0\nU factor:\n2×2 Matrix{Float64}:\n 2.0  1.0\n 0.0  1.5\n\n\n4.6.16 Copia de tipos de datos compuestas\nEn Julia cuando se asigna una variable de un tipo de datos compuesto a otra variable, no se hace una copia de la estructura de datos referenciada por la primera variable, sino que se la nueva variable apunta a la misma dirección de memoria de la estructura de datos (copia por referencia). El resultado son dos variables que apuntan a la misma estructura de datos y cualquier cambio en una de ellas se verá reflejado en la otra.\nPara hacer copias por valor de un tipo de datos compuesto debe usarse explícitamente la siguiente función:\n\nb = copy(a): Crea una copia de la estructura de datos referencia por a y asigna su referencia a b.\n\n\n\n4.6.17 Ejemplo de copia de tipos de datos compuestos\njulia> v = [1, 2, 3];\n\njulia> u = copy(v);  # Copia por valor\n\njulia> u[2] = 0;\n\njulia> u\n3-element Vector{Int64}:\n 1\n 0\n 3\n\njulia> v\n3-element Vector{Int64}:\n 1\n 2\n 3\n\njulia> u = v;  # Copia por referencia\n\njulia> u[2]=0;\n\njulia> v\n3-element Vector{Int64}:\n 1\n 0\n 3"
  },
  {
    "objectID": "tipos-datos-compuestos.html#tuplas",
    "href": "tipos-datos-compuestos.html#tuplas",
    "title": "4  Tipos de datos compuestos",
    "section": "4.7 Tuplas",
    "text": "4.7 Tuplas\nUna tupla es una colección ordenada de tamaño fijo que puede contener elementos de distintos tipos.\nGeneralmente se usan para pasar parámetros o devolver valores de funciones.\nSe crean escribiendo sus elementos separados por comas entre paréntesis.\n\n\n\n\n\n\nAdvertencia\n\n\n\nLas tuplas son inmutables, es decir, una vez creadas no pueden cambiarse sus elementos.\n\n\njulia> ()  # Tupla vacía\n()\n\njulia> (1, \"enero\", 2020) \n(1, \"enero\", 2020)\n\njulia> t = (1, \"enero\", 2020)\n(1, \"enero\", 2020)\n\njulia> typeof(t)\nTuple{Int64, String, Int64}\n\n4.7.1 Tuplas con nombres\nEs posible asignar un nombre a cada uno de los elementos de la tupla. Para ello cada elemento de la tupla con nombre debe escribirse con la sintaxis nombre = valor.\njulia> t = (día = 1, mes = \"enero\", año =  2020)\n(día = 1, mes = \"enero\", año = 2020)\n\njulia> typeof(t)\nNamedTuple{(:día, :mes, :año), Tuple{Int64, String, Int64}}\n\n\n\n\n\n\nAdvertencia\n\n\n\nNo puede haber dos elementos con el mismo nombre en una tupla.\n\n\nLa ventaja de usar tuplas con nombres es que podemos acceder a sus elementos por nombre, además de por índice.\n\n\n4.7.2 Acceso a los elementos de una tupla\nComo las tuplas tienen orden, podemos acceder a sus elementos mediante índices, al igual que con los arrays de una dimensión.\n\nt[i]: Devuelve el elemento con íncide i de la tupla t.\n\nSi la tupla tiene nombres también es posible acceder a sus elementos mediante los nombres.\n\nt.x: Devuelve el elemento con nombre x de la tupla t.\n\njulia> t = (día = 1, mes = \"enero\", año =  2020)\n(día = 1, mes = \"enero\", año = 2020)\n\njulia> t[2]\n\"enero\"\n\njulia> t.año\n2020\n\njulia> \n\n\n4.7.3 Asignación múltiple de tuplas\nEs posible asignar los elementos de una tupla a distintas variables en una sola asignación.\nx, y, ... = t: Asigna a las variables x, y, etc los elementos de la tupla t en orden. Si el número de variables es menor que el tamaño de la tupla, los últimos elementos quedan sin asignar.\nx, y... = t: Asigna el primer elemento de la tupla t a la variable x y la tupla con los elementos restantes a la variable y.\n\n\n4.7.4 Ejemplo de asignación múltipe de tuplas\njulia> t = (1, \"enero\", 2020)\n(1, \"enero\", 2020)\n\njulia> d, m, a = t\n(1, \"enero\", 2020)\n\njulia> d\n1\n\njulia> m\n\"enero\"\n\njulia> a\n2020\n\njulia> d, ma... = t \n(1, \"enero\", 2020)\n\njulia> d\n1\n\njulia> ma\n(\"enero\", 2020)"
  },
  {
    "objectID": "tipos-datos-compuestos.html#diccionarios",
    "href": "tipos-datos-compuestos.html#diccionarios",
    "title": "4  Tipos de datos compuestos",
    "section": "4.8 Diccionarios",
    "text": "4.8 Diccionarios\nUn diccionario es una colección asociativa sin orden cuyos elementos son pares formados por una clave y un valor asociado a la clave.\nSe parecen a las tuplas con nombre, pero, a diferencia de estas, son mutables, es decir, su contenido se puede alterar.\nSe construyen con la siguiente constructor:\n\nDict(k1 => v1, ...): Crea un diccionario con los pares indicados en formato clave => valor.\n\n\n\n\n\n\n\nAdvertencia\n\n\n\nEn un diccionario no pueden existir dos pares con la misma clave, de modo que si se repite una clave se sobrescribe el par anterior.\n\n\n\n4.8.1 Ejemplo de diccionarios\njulia> Dict()  # Diccionario vacío\nDict{Any, Any}()\n\njulia> d = Dict(\"ES\" => \"Euro\", \"US\" => \"Dollar\", \"CN\" => \"Yuan\")\nDict{String, String} with 3 entries:\n  \"CN\" => \"Yuan\"\n  \"ES\" => \"Euro\"\n  \"US\" => \"Dollar\"\n\njulia> typeof(d)\nDict{String, String}\n\n\n4.8.2 Comprensión de diccionarios\nAl igual que para arrays se puede usar la técnica de compresión para generar diccionarios a partir de uno o varios iteradores.\n\nDict(kexp => vexp for i = ite): Devuelve el diccionario cuyos pares están formados por la claves y valores resultan de evaluar las expresiones kexp y vexp respectivamente, para cada valor i del iterador ite.\nDict(kexp => vexp for i = ite if cond): Devuelve el diccionario cuyos pares están formados por la claves y valores resultan de evaluar las expresiones kexp y vexp respectivamente, para cada valor i del iterador ite que cumpla condición cond.\n\nSe pueden utilizar más de un iterador después de la palabra reservada for.\n\n\n4.8.3 Ejemplo de comprensión de diccionarios\njulia> Dict(i => i^2 for i = 1:4)\nDict{Int64, Int64} with 4 entries:\n  4 => 16\n  2 => 4\n  3 => 9\n  1 => 1\n\njulia> Dict(i => i^2 for i = 1:4 if i % 2 == 0)\nDict{Int64, Int64} with 2 entries:\n  4 => 16\n  2 => 4\n\njulia> Dict((i, j) => i + j for i = 1:2, j = 3:4)\nDict{Tuple{Int64, Int64}, Int64} with 4 entries:\n  (2, 4) => 6\n  (1, 3) => 4\n  (1, 4) => 5\n  (2, 3) => 5\n\n\n4.8.4 Acceso a los elementos de un diccionario\nPara acceder a los valores de un diccionario se utilizan sus claves asociadas entre corchetes.\n\nd[k]: Devuelve el valor asociado a la clave k en el diccionario d.\n\n\n\n\n\n\n\nAdvertencia\n\n\n\nSi la clave no existe en el diccionario se produce un error.\n\n\nPara evitar errores es conveniente usar alguna de las siguientes funciones:\n\nhaskey(d, k): Devuelve true la clave k está en diccionario d y false en caso contrario.\nget(d, k, v): Devuelve el valor asociado a la clave k en el diccionario d o el valor v si la clave k no existe.\nget!(d, k, v): Devuelve el valor asociado a la clave k en el diccionario d. Si la clave k no existe en el diccionario d añade el par con la clave k y el valor v y devuelve el valor v.\n\n\n\n4.8.5 Ejemplo de acceso a los elementos de un diccionario\njulia> d = Dict(\"ES\" => \"Euro\", \"US\" => \"Dollar\", \"CN\" => \"Yuan\")\nDict{String, String} with 3 entries:\n  \"CN\" => \"Yuan\"\n  \"ES\" => \"Euro\"\n  \"US\" => \"Dollar\"\n\njulia> d[\"ES\"]\n\"Euro\"\n\njulia> d[\"JP\"]\nERROR: KeyError: key \"JP\" not found\nStacktrace:\n [1] getindex(h::Dict{String, String}, key::String)\n   @ Base ./dict.jl:481\n [2] top-level scope\n   @ REPL[22]:1\n\njulia> get(d, \"JP\", \"Dollar\")\n\"Dollar\"\n\njulia> get!(d, \"JP\", \"Yen\")\n\"Yen\"\n\njulia> d\nDict{String, String} with 4 entries:\n  \"CN\" => \"Yuan\"\n  \"ES\" => \"Euro\"\n  \"JP\" => \"Yen\"\n  \"US\" => \"Dollar\"\n\n\n4.8.6 Recorrido de las claves y valores de un diccionario\nLas siguientes funciones permiten obtener todas las claves, valores y pares de un diccionario.\n\nkeys(d): Devuelve un iterador con las claves del diccionario d.\nvalues(d): Devuelve un iterador con los valores del diccionario d.\n\nEstos iteradores permiten recorrer fácilmente los pares de un diccionario.\n\n\n4.8.7 Ejemplo de recorrido de las claves y valores de un diccionario\njulia> d = Dict(\"ES\" => \"Euro\", \"US\" => \"Dollar\", \"CN\" => \"Yuan\")\nDict{String, String} with 3 entries:\n  \"CN\" => \"Yuan\"\n  \"ES\" => \"Euro\"\n  \"US\" => \"Dollar\"\n\njulia> keys(d)\nKeySet for a Dict{String, String} with 3 entries. Keys:\n  \"CN\"\n  \"ES\"\n  \"US\"\n\njulia> values(d)\nValueIterator for a Dict{String, String} with 3 entries. Values:\n  \"Yuan\"\n  \"Euro\"\n  \"Dollar\"\n\njulia> for k = keys(d)\n         println(\"$k = $(d[k])\")\n       end\nCN = Yuan\nES = Euro\nUS = Dollar\n\njulia> for (k, v) = d\n       println(\"$k = $v\")\n       end\nCN = Yuan\nES = Euro\nUS = Dollar\n\n\n4.8.8 Añadir elementos a un diccionario\nSe pueden añadir pares nuevos a un diccionario de la siguiente manera:\n\nd[k] = v: Añade el par con clave k y valor v al diccionario d. Si la clave k ya existía en el diccionario d, cambia su valor asociado por v.\npush!(d, k => v): Añade el par con clave k y valor asociado v al diccionario d.\n\njulia> d = Dict(\"ES\" => \"Euro\", \"US\" => \"Dollar\")\nDict{String, String} with 2 entries:\n  \"ES\" => \"Euro\"\n  \"US\" => \"Dollar\"\n\njulia> d[\"CN\"] = \"Yuan\"\n\"Yuan\"\n\njulia> push!(d, \"JP\" => \"Yen\")\nDict{String, String} with 4 entries:\n  \"CN\" => \"Yuan\"\n  \"ES\" => \"Euro\"\n  \"JP\" => \"Yen\"\n  \"US\" => \"Dollar\"\n\n\n4.8.9 Eliminar elementos de un diccionario\nPara eliminar un par de un diccionario se utiliza la siguiente función:\n\ndelete!(d, k): Elimina el par cuya clave es k del diccionario d.\n\njulia> d = Dict(\"ES\" => \"Euro\", \"US\" => \"Dollar\", \"CN\" => \"Yuan\")\nDict{String, String} with 3 entries:\n  \"CN\" => \"Yuan\"\n  \"ES\" => \"Euro\"\n  \"US\" => \"Dollar\"\n\njulia> delete!(d, \"US\")\nDict{String, String} with 2 entries:\n  \"CN\" => \"Yuan\"\n  \"ES\" => \"Euro\""
  },
  {
    "objectID": "tipos-datos-compuestos.html#conjuntos",
    "href": "tipos-datos-compuestos.html#conjuntos",
    "title": "4  Tipos de datos compuestos",
    "section": "4.9 Conjuntos",
    "text": "4.9 Conjuntos\nUn conjunto es una colección de elementos del mismo tipo sin orden y sin repeticiones.\nSe construyen con la siguiente constructor:\n\nSet(a): Crea un conjunto con los elementos del array a.\n\nAl igual que para arrays el tipo se infiere automáticamente a partir de los tipos de sus elementos. Si los elementos son de distintos tipos se convierten al tipo más específico de la jerarquía de tipos del que los tipos de los elementos son subtipos.\n\n\n\n\n\n\nAdvertencia\n\n\n\nUn conjunto no puede tener elementos repetidos, por lo que si el array contiene elementos repetidos solo se incluyen una vez.\n\n\n\n4.9.1 Ejemplo de construcción de conjuntos\njulia> Set()\nSet{Any}()\n\njulia> c = Set([1, \"2\", 3])\nSet{Any} with 3 elements:\n  \"2\"\n  3\n  1\n\njulia> typeof(c)\nSet{Any}\n\n\n4.9.2 Añadir elementos a un conjunto\nPara añadir elementos a un conjunto se utiliza la siguiente función:\n\npush!(c, e): Añade el elemento e al conjunto c.\n\n\n\n\n\n\n\nAdvertencia\n\n\n\nSi el elemento que se quiere añadir es de distinto tipo que los elemento del conjunto y no puede convertirse a este tipo, se produce un error.\n\n\n\n\n4.9.3 Ejemplo de añadir elementos a un conjunto\njulia> c = Set(1:3)\nSet{Int64} with 3 elements:\n  2\n  3\n  1\n\njulia> push!(c, 4)\nSet{Int64} with 4 elements:\n  4\n  2\n  3\n  1\n\njulia> push!(c, \"cinco\")\nERROR: MethodError: Cannot `convert` an object of type String to an object of type Int64\nClosest candidates are:\n  convert(::Type{T}, ::T) where T<:Number at /usr/share/julia/base/number.jl:6\n  convert(::Type{T}, ::Number) where T<:Number at /usr/share/julia/base/number.jl:7\n  convert(::Type{T}, ::Base.TwicePrecision) where T<:Number at /usr/share/julia/base/twiceprecision.jl:262\n  ...\n\n\n4.9.4 Eliminar elementos de un conjunto\nPara eliminar elementos de un conjunto se utiliza la siguiente función:\n\ndelete!(c, e): Elimina el elemento e del conjunto c.\n\njulia> c = Set(1:3)\nSet{Int64} with 3 elements:\n  2\n  3\n  1\n\njulia> delete!(c, 2)\nSet{Int64} with 2 elements:\n  3\n  1\n\n\n4.9.5 Recorrido de los elementos de un conjunto\nUn conjunto puede utilizarse también como un iterador para recorrer sus elementos.\njulia> c = Set(1:3)\nSet{Int64} with 3 elements:\n  2\n  3\n  1\n\njulia> for i = c\n         println(i)\n       end\n2\n3\n1\n\n\n4.9.6 Pertenencia e inclusión de conjuntos\n\nin(e, c), e ∈ c : Devuelve true si el elemento e pertenece al conjunto c y false en caso contrario.\ne ∉ c: Devuelve true si el elemento e no pertenece al conjunto c y false en caso contrario.\nissubset(a, b), a ⊆ b: Devuelve true si todos los elementos de a pertenecen a b y false en caso contrario.\na ⊈ b: Devuelve true si hay algún elemento de a que no pertenece a b.\na ⊊ b: Devuelve true si el conjunto a está contenido estrictamente en el conjunto b, es decir, todos los elementos de a pertenecen a b pero a y b son distintos.\nisdisjoint(a, b): Devuelve true si los conjuntos a y b no tienen elementos en común y false en caso contrario.\n\n\n\n4.9.7 Ejemplos de pertenencia e inclusión de conjuntos\njulia> a = Set(1:3);\n\njulia> in(2, a)\ntrue\n\njulia> 3 ∉ a\nfalse\n\njulia> b = Set([3, 2, 1]);\n\njulia> a ⊊ b\nfalse\n\njulia> a ⊆ b\ntrue\n\njulia> isdisjoint(a, b)\nfalse\n\n\n4.9.8 Álgebra de conjuntos\n\nunion(a, b), a ∪ b: Devuelve el conjunto unión de los conjuntos a y b.\nintersect(a, b), a ∩ b: Devuelve el conjunto intersección de los conjuntos a y b.\nsetdiff(a, b): Devuelve el conjunto diferencia del conjunto a y b.\nsymdiff(a, b): Devuelve el conjunto diferencia simétrica de los conjuntos a y b.\n\nExisten versiones de estas funciones acabadas en ! que sobreescriben el conjunto dado como primer argumento con el resultado de la operación.\n\n\n4.9.9 Ejemplo de álgebra de conjuntos\njulia> a = Set(1:3)\nSet{Int64} with 3 elements:\n  2\n  3\n  1\n\njulia> b = Set(2:2:6)\nSet{Int64} with 3 elements:\n  4\n  6\n  2\n\njulia> union(a, b)\nSet{Int64} with 5 elements:\n  4\n  6\n  2\n  3\n  1\n\njulia> intersect(a, b)\nSet{Int64} with 1 element:\n  2\n\njulia> setdiff(a, b)\nSet{Int64} with 2 elements:\n  3\n  1\n\njulia> symdiff(a, b) == setdiff(a ∪ b, a ∩ b)\ntrue"
  },
  {
    "objectID": "funciones.html",
    "href": "funciones.html",
    "title": "5  Funciones",
    "section": "",
    "text": "Una función asocia un nombre a un bloque de código de manera que cada vez que se invoca a la función se ejecuta el bloque de código asociado.\nPara crear una función se utiliza la siguiente sintaxis\n\nfunction nombre(parámetros)\n   bloque de código\nend\n\n\n\n\n\n\n\nNota\n\n\n\nLa indentación del bloque de código no es necesaria pero es una buena práctica.\n\n\nPara invocar una función basta con escribir su nombre y pasarle entre paréntesis los valores de los parámetros (argumentos) separados por comas.\n\n\njulia> function saludo()  # Función sin parámetros\n         println(\"¡Bienvenido!\")\n       end\nsaludo (generic function with 1 method)\n\njulia> saludo()\n¡Bienvenido!\n\njulia> typeof(saludo)\ntypeof(saludo) (singleton type of function saludo, subtype of Function)"
  },
  {
    "objectID": "funciones.html#parámetros-y-argumentos-de-una-función",
    "href": "funciones.html#parámetros-y-argumentos-de-una-función",
    "title": "5  Funciones",
    "section": "5.2 Parámetros y argumentos de una función",
    "text": "5.2 Parámetros y argumentos de una función\nUna función puede recibir valores cuando se invoca a través de unas variables conocidas como parámetros que se definen entre paréntesis y separados por comas en la declaración de la función. En el cuerpo de la función se pueden usar estos parámetros como si fuesen variables.\nLos valores que se pasan a la función en una llamada o invocación concreta de ella se conocen como argumentos y se asocian a los parámetros de la declaración de la función.\njulia> function calificacion(nota)  # Función con un parámetro\n         if nota < 5\n           println(\"Suspenso\")\n         else\n           println(\"Aprobado\")\n         end\n       end\ncalificacion (generic function with 1 method)\n\njulia> calificacion(7)\nAprobado\n\n5.2.1 Paso de argumentos a una función\nLos argumentos se pueden pasar de dos formas:\n\nArgumentos posicionales: Se asocian a los parámetros de la función en el mismo orden que aparecen en la definición de la función.\nArgumentos nominales: Se indica explícitamente el nombre del parámetro al que se asocia un argumento de la forma parametro = argumento.\n\nCuando una función tiente parámetros posicionales y como nominales, los posicionales deben indicarse primero y los nominales después, separando ambos tipos de parámetros por punto y coma ;.\n\n\n5.2.2 Ejemplo de paso de argumentos a una función\njulia> function saludo(nombre, apellidos; ciudad)\n       println(\"¡Hola $nombre $apellidos, bienvenido a $(ciudad)!\")\n       end\nsaludo (generic function with 1 method)\n\njulia> saludo(\"Alfredo\", \"Sánchez\", ciudad = \"Madrid\")\n¡Hola Alfredo Sánchez, bienvenido a Madrid!\n\njulia> saludo(\"Alfredo\", ciudad = \"Madrid\",  \"Sánchez\")\n¡Hola Alfredo Sánchez, bienvenido a Madrid!\n\n\n5.2.3 Argumentos por defecto\nEn la definición de una función se puede asignar a cada parámetro un argumento por defecto, de manera que si se invoca la función sin proporcionar ningún argumento para ese parámetro, se utiliza el argumento por defecto.\nEl valor por defecto de un parámetro se indica con la siguiente sintaxis parámetro = valor.\njulia> function saludo(nombre, apellidos, ciudad = \"Madrid\")\n         println(\"¡Hola $nombre $apellidos, bienvenido a $(ciudad)!\")\n       end\nsaludo (generic function with 2 methods)\n\njulia> saludo(\"Alfredo\", \"Sánchez\")\n¡Hola Alfredo Sánchez, bienvenido a Madrid!\n\njulia> saludo(\"Pepito\", \"Grillo\", \"Barcelona\")\n¡Hola Pepito Grillo, bienvenido a Barcelona!\n\n\n5.2.4 Funciones con un número variable de argumentos\nJulia permite definir funciones que pueden llamarse con un número variable de argumentos. Para que una función pueda recibir un número variable de argumentos hay que poner tres puntos suspensivos ... al final de último parámetro posicional.\nCuando se llame a la función los argumentos se irán asociando a los parámetros posicionales en orden y el último parámetro se asociará a una tupla con el resto de argumentos en la llamada.\njulia> function media(x...)\n       println(\"Media de \", x)\n       sum(x) / length(x)\n       end\nmedia (generic function with 1 method)\n\njulia> media(1, 2, 3, 4)\nMedia de (1, 2, 3, 4)\n2.5\n\n\n5.2.5 Parámetros con tipo\nAunque Julia es un lenguaje de tipado dinámico también permite fijar el tipo de los parámetros de una una función. Esto permite definir diferentes variantes (métodos) de una misma función dependiendo del tipo de los argumentos, así como detectar errores cuando se llama a la función con argumentos de distinto tipo.\nPara indicar el tipo de los parámetros de una función se utiliza la sintaxis parametro::tipo.\n\n\n\n\n\n\nAdvertencia\n\n\n\nConviene no restringir demasiado el tipo de los parámetros de una función. Se debe elegir el tipo más general en la jerarquía de tipos para el que tiene sentido la función.\n\n\n\n\n5.2.6 Ejemplo de parámetros con tipo\njulia> function sumar(x::Number, y::Number)\n       x + y\n       end\nsumar (generic function with 1 method)\n\njulia> function sumar(x::String, y::String)\n       x * y\n       end\nsumar (generic function with 2 methods)\n\njulia> sumar(1, 2)\n3\n\njulia> sumar(1.5, 2.5)\n4.0\n\njulia> sumar(\"Hola\", \"Julia\")\n\"HolaJulia\"\n\n\n5.2.7 Paso de argumentos por asignación\nEn Julia los argumentos se pasan a una función por asignación, es decir, se asignan a los parámetros de la función como si fuesen variables locales. De este modo, cuando los argumentos son objetos mutables (arrays, diccionarios, etc.) se pasa al parámetro una referencia al objeto, de manera que cualquier cambio que se haga en la función mediante el parámetro asociado afectará al objeto original y serán visibles fuera de ella.\njulia> function matricular(curso, asignatura)\n       push!(curso, asignatura)\n       end\nmatricular (generic function with 1 method)\n\njulia> primer_curso = [];\n\njulia> matricular(primer_curso, \"Álgebra Lineal\");\n\njulia> matricular(primer_curso, \"Programación\");\n\njulia> primer_curso\n2-element Vector{Any}:\n \"Álgebra Lineal\"\n \"Programación\"\n\n\n5.2.8 Ámbito de los parámetros de una función\nLos parámetros y las variables declaradas dentro de una función son de ámbito local, mientras que las variable definidas fuera de funciones son de ámbito ámbito global.\nTanto los parámetros como las variables del ámbito local de una función sólo están accesibles durante la ejecución de la función. Es decir, cuando termina la ejecución de la función estas variables desaparecen y no son accesibles desde fuera de la función.\nSi en el ámbito local de una función existe una variable que también existe en el ámbito global, durante la ejecución de la función la variable global queda eclipsada por la variable local y no es accesible hasta que finaliza la ejecución de la función.\n\n\n5.2.9 Ejemplo del ámbito de los parámetros de una función\njulia> lenguaje = \"Python\";\n\njulia> function saludo(nombre)\n       lenguaje = \"Julia\"\n       println(\"¡Hola $(nombre), bienvenido a $(lenguaje)!\")\n       end\nsaludo (generic function with 3 methods)\n\njulia> saludo(\"Alf\")\n¡Hola Alf, bienvenido a Julia!\n\njulia> lenguaje\n\"Python\"\n\njulia> nombre\nERROR: UndefVarError: nombre not defined"
  },
  {
    "objectID": "funciones.html#retorno-de-una-función",
    "href": "funciones.html#retorno-de-una-función",
    "title": "5  Funciones",
    "section": "5.3 Retorno de una función",
    "text": "5.3 Retorno de una función\nUna función devuelve siempre el valor de la última expresión evaluada en su cuerpo. Sin embargo, puede devolverse cualquier otro valor indicándolo detrás de la palabra reservada return. Cuando el flujo de ejecución de la función alcanza esta palabra, la ejecución de la función termina y se devuelve el valor que la acompaña.\nSi una función no devuelve ningún valor se puede escribir la palabra return sin nada más.\nCuando se desea devolver más de un valor se puede pueden indicar separados por comas y la función devolverá la tupla formada por esos valores.\n\n5.3.1 Ejemplo de retorno de una función\njulia> function area_triangulo(base, altura)\n         return base * altura / 2  # Devuelve un valor\n       end\narea_triangulo (generic function with 1 method)\n\njulia> area_triangulo(3, 4)\n6.0\n\njulia> function area_perimetro_circulo(r)\n         return π * r ^ 2, 2π * r  # Devuelve dos valores \n       end\narea_perimetro_circulo (generic function with 1 method)\n\njulia> area_perimetro_circulo(1)\n(3.141592653589793, 6.283185307179586)"
  },
  {
    "objectID": "funciones.html#funciones-compactas",
    "href": "funciones.html#funciones-compactas",
    "title": "5  Funciones",
    "section": "5.4 Funciones compactas",
    "text": "5.4 Funciones compactas\nCuando el cuerpo de una función es una única expresión se puede definir la función de forma mucho más compacta de la siguiente manera:\n\nnombre(parametros) = expresión\n\nEl valor que devuelve la función es el resultado de evaluar la expresión.\nEsta forma de definir funciones es muy habitual para funciones matemáticas.\njulia> area_triangulo(b, a) = b * a / 2\narea_triangulo (generic function with 1 method)\n\njulia> area_triangulo(3, 4)\n6.0\n\njulia> valor_absoluto(x) = x < 0 ? -x : x\nvalor_absoluto (generic function with 1 method)\n\njulia> valor_absoluto(-1)\n1"
  },
  {
    "objectID": "funciones.html#funciones-como-objetos",
    "href": "funciones.html#funciones-como-objetos",
    "title": "5  Funciones",
    "section": "5.5 Funciones como objetos",
    "text": "5.5 Funciones como objetos\nEn Julia las funciones son objetos como el resto de tipos de datos, de manera que es posible asignar una función a una variable y luego utilizar la variable para hacer la llamada a la función, pasar una función como argumento de otra función, o que una función devuelva otra función.\njulia> suma(x, y) = x + y\nsuma (generic function with 1 method)\n\njulia> adicion = suma\nsuma (generic function with 1 method)\n\njulia> adicion(1, 2)\n3\n\njulia> calculadora(operador, x, y) = operador(x, y) \ncalculadora (generic function with 1 method)\n\njulia> calculadora(suma, 1, 2)\n3"
  },
  {
    "objectID": "funciones.html#funciones-anónimas",
    "href": "funciones.html#funciones-anónimas",
    "title": "5  Funciones",
    "section": "5.6 Funciones anónimas",
    "text": "5.6 Funciones anónimas\nJulia permite también definir funciones sin nombre. Para ello se utiliza la siguiente sintaxis.\n\n(parametros) -> expresión\n\nEl principal uso de las funciones anónimas es para pasarlas como argumentos de otras funciones.\nulia> calculadora(operador, x, y) = operador(x, y) \ncalculadora (generic function with 1 method)\n\njulia> calculadora((x, y) -> x + y, 1, 2)\n3\n\njulia> calculadora((x, y) -> x - y, 1, 2)\n-1"
  },
  {
    "objectID": "funciones.html#funciones-asociadas-a-operadores",
    "href": "funciones.html#funciones-asociadas-a-operadores",
    "title": "5  Funciones",
    "section": "5.7 Funciones asociadas a operadores",
    "text": "5.7 Funciones asociadas a operadores\nEn Julia los operadores tienen asociadas funciones que son llamadas por el intérprete cuando se evalúa una expresión con operadores.\njulia> +(1, 2, 3)  # Equivalente a 1 + 2 + 3\n6\n\njulia> ∑ = +\n+ (generic function with 208 methods)\n\njulia> ∑(1, 2, 3)\n6"
  },
  {
    "objectID": "funciones.html#funciones-recursivas",
    "href": "funciones.html#funciones-recursivas",
    "title": "5  Funciones",
    "section": "5.8 Funciones recursivas",
    "text": "5.8 Funciones recursivas\nUna función recursiva es una función que en su cuerpo contiene alguna llama a si misma.\nLa recursión es una práctica común en la mayoría de los lenguajes de programación ya que permite resolver las tareas recursivas de manera más natural.\nPara garantizar el final de una función recursiva, las sucesivas llamadas tienen que reducir el grado de complejidad del problema, hasta que este pueda resolverse directamente sin necesidad de volver a llamar a la función.\n\n\n\n\n\n\nPrecaución\n\n\n\nLa recursión es una técnica que suele ser poco eficiente computacionalmente y conviene evitarla siempre que sea posible.\n\n\n\n5.8.1 Ejemplo de funciones recursivas\njulia> function factorial(n::Integer)\n         if n <= 1\n           return 1\n         else\n           return n * factorial(n-1)\n         end\n       end\nfactorial (generic function with 1 method)\n\njulia> factorial(4)\n24\n\njulia> fib(n::Integer) = n ≤ 2 ? 1 : fib(n - 1) + fib(n - 2)\nfib (generic function with 1 method)\n\njulia> fib(10)\n55"
  },
  {
    "objectID": "graficos.html",
    "href": "graficos.html",
    "title": "6  Gráficos",
    "section": "",
    "text": "Existen muchos paquetes para la representación gráfica en Julia. Los más usados son:\n\nPlots.jl\nGadFly.jl.\nVegaLite.jl"
  },
  {
    "objectID": "graficos.html#gráficos-con-el-paquete-plots.jl",
    "href": "graficos.html#gráficos-con-el-paquete-plots.jl",
    "title": "6  Gráficos",
    "section": "6.2 Gráficos con el paquete Plots.jl",
    "text": "6.2 Gráficos con el paquete Plots.jl\nPlots.js es el paquete más usado por disponer de más posibilidades gráficas y ser bastante sencillo de usar.\nImplementa una interfaz para otras librerías gráficas (backends), por lo que en algunas ocasiones puede ser bastante lento al tener que llamar a otras librerías.\n\n\n6.2.1 Backends de Plot.jl\n\nGR. Es el backend pro defecto. Es bastante rápida y permite tanto gráficos 2D como 3D no interactivos. Se inicializa con la función gr(). (Ver ejemplos)\nPlotlyJS. Es más lenta pero permite gráficos 2D y 3D interactivos con un montón de funcionalidades. Se inicializa con la función plotlyjs(). (Ver ejemplos)\nPyPlot. Utiliza la librería gráfica Matplotlib de Python por lo que es bastante lenta. Sin embargo, tiene ofrece todas las posibilidades de Matplotlib que es bastante madura. Se inicializa con la función pyplot(). (Ver ejemplos)\nPGFPlotsX. Utiliza la librería PGF/TikZ de LaTeX por lo que genera gráficos de muy alta calidad tanto en 2D como 3D, especialmente para publicaciones.Se inicializa con la función pgfplotsx(). (Ver ejemplos)\nUnicodePlots. Permite dibujar gráficos en la terminal. Los gráficos son de poca calidad pero funciona con gran rapidez. Se inicializa con la función unicodeplots(). (Ver ejemplos)\n\n\n\n6.2.2 Gráfica de una función de una variable\n\nplot(f, min, max): Dibuja la gráfica de la función de una variable f para argumentos desde xmin a xmax.\n\n\nusing Plots\n\nf(x) = exp(-x^2 / 2)\nplot(f, -3, 3)\n\n\n\n\n\n\n\n6.2.3 Gráficas de varias funciones\n\nplot!(f, xmin, xmax): Añade la gráfica de la función de una variable f para argumentos desde xmin a xmax al último gráfico realizado.\n\n\nusing Plots\n\nf(x) = sin(x)\ng(x) = cos(x)\nplot(f, -0, 2π)\nplot!(g)\n\n\n\n\n\n\n6.2.4 Añadir puntos a una gráfica\n\nscatter(x, y): Dibuja los puntos con coordenadas x en el vector x y coordenadas y en el vector y.\n\n\nusing Plots\n\nf(x) = sin(x)\ng(x) = cos(x)\nplot(f, -0, 2π)\nplot!(g)\nx = [π/4, 5π/4]\ny = sin.(x)\nscatter!(x, y)\n\n\n\n\n\n\n6.2.5 Ventana de graficación\nEs posible restringir el área de graficación (rango de valores de los ejes) de una función añadiendo los parámetros xlims =(xmin, xmax) para establecer el rango del eje x o ylims = (ymin, ymax) para establecer el rango del eje y.\n\nusing Plots\n\nf(x) = 1 / x\nplot(f, -1, 1, ylims = (-10, 10))\n\n\n\n\n\n\n6.2.6 Restringir la gráfica al dominio\nCuando una función no está definida para algún valor del rango de valores del eje x dado, la gráfica muestra una línea recta desde el punto de la gráfica anterior hasta el punto siguiente al punto donde la función no existe.\nEste comportamiento no es deseable puesto que si la función no existe en un punto no debería existir gráfica para ese punto.\nLa siguiente función del paquete MATH229 se encarga de evitar esto.\n\nrangeclamp(f): Devuelve una función idéntica a la función f excepto para los puntos donde la función no existe o es infinito que devuelve NaN.\n\n\n\n6.2.7 Ejemplo de restringir la gráfica al dominio\n\nusing Plots\nusing MTH229\n\nf(x) = 1 / x\nplot(rangeclamp(f), -1, 1)\n\n\n\n\n\n\n6.2.8 Gráficas paramétricas\nLa función plot también permite dibujar gráficas de funciones paramétricas pasándole las funciones de las coordenadas x e y.\n\nplot(f, g, min, max): Dibuja la gráfica de la función paramétrica \\((f(t), g(t))\\) para valores del parámetro t entre min y max.\n\n\nusing Plots\nf(x) = sin(x)\ng(x) = sin(2x)\nplot(f, g, 0, 2π)\n\n\n\n\n\n\n6.2.9 Personalización de gráficos\nLos siguientes parámetros pueden añadirse a la función plot para modificar el aspecto de los gráficos.\n\ntitle: Añade un título principal al gráfico.\nxlab: Añade un título al eje x.\nylab: Añade un título al eje y.\ncolor: Establece el color de la gráfica.\nlinewidth: Establece el grosor de la línea de la gráfica.\nlinestyle: Establece el estilo de la línea de la gráfica.\naspect_ratio: Establece la relación de aspecto entre la escala de los ejes.\nlegend: Activa o desactiva la leyenda del gráfico.\n\n\n\n6.2.10 Ejemplo de personalización de gráficos\n\nusing Plots\n\nf(x) = sin(x)\nplot(f, -π, π, title = \"Gráfica del seno\",  xlab = \"x\", ylab = \"f(x) = sen(x)\",\n  color = \"green\", linewidth = 3, linestyle = :dash, legend = false)"
  },
  {
    "objectID": "graficos.html#gráficos-en-el-espacio-real",
    "href": "graficos.html#gráficos-en-el-espacio-real",
    "title": "6  Gráficos",
    "section": "6.3 Gráficos en el espacio real",
    "text": "6.3 Gráficos en el espacio real\nPara dibujar superficies en el espacio real se utiliza la función\nsurface(x, y, f): Dibuja la superficie de la función \\(f(x,y)\\) en el rango de valores x del eje x e y del eje y.\n\nusing Plots\npyplot()\nx = range(1, stop=10, length=100)\ny = x\nf(x,y) = sin(x) + cos(y)\nplot(x, y, f, st=:surface)"
  },
  {
    "objectID": "graficos.html#gráficos-con-gadfly.jl",
    "href": "graficos.html#gráficos-con-gadfly.jl",
    "title": "6  Gráficos",
    "section": "6.4 Gráficos con GadFly.jl",
    "text": "6.4 Gráficos con GadFly.jl\nGadFly.js es un paquete nativo que genera gráficos interactivos 2D y 3D por medio de librerías de Javascript basadas en la gramática de gráficos (usada también por el paquete ggplot2 de R).\nAl estar implementado en Julia es mucho más rápido que Plots.js pero ofrece menos posibilidades."
  },
  {
    "objectID": "graficos.html#gráficos-con-vegalite.jl",
    "href": "graficos.html#gráficos-con-vegalite.jl",
    "title": "6  Gráficos",
    "section": "6.5 Gráficos con VegaLite.jl",
    "text": "6.5 Gráficos con VegaLite.jl\nVegaLite.jl es un paquete que genera gráficos estáticos por medio de las librerías de Javascript de la gramática de gráficos Vega.\nDispone de muchas más opciones de personalización de gráficos que GadFly.jl."
  },
  {
    "objectID": "calculo-simbolico.html",
    "href": "calculo-simbolico.html",
    "title": "7  Cálculo simbólico",
    "section": "",
    "text": "Symbolics.jl es un paquete que implementa un avanzado Sistema de Álgebra Computacional (CAS) basado en un lenguaje de modelado simbólico.\nLas variables y las expresiones simbólicas pueden utilizarse con la mayoría de las funciones de Julia para cálculo numérico, por lo que se integran a la perfección en el ecosistema de Julia.\n\n\n\nPara declarar variables simbólicas se utiliza la siguiente macro:\n\n@variables x y ...: Declara las variables x, y, etc. como variables simbólicas.\n\nEl tipo de las variables simbólicas es Num.\nCualquier expresión en la que interviene una variable simbólica se convierte automáticamente en una expresión simbólica.\n\n\n\nusing Symbolics\n\njulia> @variables x y\n2-element Vector{Num}:\n x\n y\n\njulia> z = x^2 - y\nx^2 - y\n\njulia> typeof(z)\nNum\n\njulia> A = [x + y 2x; -y y - x]  # Matriz simbólica\n2×2 Matrix{Num}:\n x + y     2x\n    -y  y - x\n\n\n\nSe pueden realizar operaciones algebraicas con expresiones simbólicas utilizando los mismos operadores del Álgebra numérica.\nusing Symbolics\n\njulia> @variables x y;\n\njulia> (x + 1) + (x + 2)\n3 + 2x\n\njulia> A = [x + y 2x; -y y - x]  # Matriz simbólica\n2×2 Matrix{Num}:\n x + y     2x\n    -y  y - x\n\njulia> B = [x, y]  # Vector simbólico\n2-element Vector{Num}:\n x\n y\n\njulia> A * B  # Producto matricial\n2-element Vector{Num}:\n x*(x + y) + 2x*y\n  y*(y - x) - x*y\n\n\n\nPara simplificar expresiones simbólicas se utiliza la siguiente función:\n\nsimplify(e): Devuelve la expresión simbólica que resulta de simplificar la expresión simbólica e.\n\nLa simplificación utiliza el paquete SymbolicUtils.jl que implementa un potente sistema de reescritura de términos.\nusing Symbolics\n\n@variables x y;\n\njulia> simplify(2(x+y))\n2x + 2y\n\njulia> simplify(2(x+y))\n2x + 2y\n\njulia> simplify(sin(x)^2 + cos(x)^2)\n1\n\n\n\nPara sustituir una variable simbólica en una expresión se utiliza la siguiente función:\n\nsubstitute(e, d): Realiza la sustitución de las claves por los valores del diccionario d en la expresión simbólica e.\n\nusing Symbolics\n\n@variables x y;\n\njulia> substitute(cos(2x), Dict([x => π])) \n1.0\n\njulia> substitute(x * y + 2x -y + 2, Dict([x => 1, y => 2]))\n4\n\n\n\nPara definir una ecuación se utiliza el símbolo ~ en lugar de la igualdad.\nPara resolver una ecuación se utiliza la siguiente función:\n\nSymbolics.solve_for(eq, var): Devuelve un vector con los valores de las variables del vector var que cumplen la ecuación o sistema de ecuaciones eq, siempre que la ecuación tenga solución.\n\n\n\n\n\n\n\nAdvertencia\n\n\n\nActualmente solo funciona para ecuaciones lineales.\n\n\nusing Symbolics\n\n@variables x y;\n\njulia> Symbolics.solve_for(x + y ~ 0, x)\n-y\n\njulia> Symbolics.solve_for([x + y ~ 4, x - y ~ 2], [x, y])\n2-element Vector{Float64}:\n 3.0\n 1.0\n\n\n\nPara calcular la derivada de una función se utiliza la siguiente función:\n\nSymbolics.derivative(f, x): Devuelve la expresión simbólica de la derivada de la función f con respecto a la variable simbólica x.\n\nusing Symbolics\n\njulia> @variables x y;\n\njulia> Symbolics.derivative(exp(x*y), x)\ny*exp(x*y)\n\njulia> Symbolics.derivative(Symbolics.derivative(exp(x*y), x), y)\nx*y*exp(x*y) + exp(x*y)\n\n\n\nPara construir un operador diferencial (\\(\\frac{d}{dx}\\)) se utiliza la siguiente función:\n\nDifferential(x): Crea el operador diferencial con respecto a la variable simbólica x.\n\nPara obtener la función derivada, una vez aplicado el operador diferencial a una función, es necesario aplicar la siguiente función:\n\nexpand_derivatives(D(f)): Devuelve la expresión simbólica que corresponde a la derivada de la función f con respecto a la variable del operador diferencial D.\n\n\n\n\nusing Symbolics\n\n@variables x y;\n\njulia> Dx = Differential(x)\n(::Differential) (generic function with 2 methods)\n\njulia> f(x) = sin(x^2)\nf (generic function with 1 method)\n\njulia> f1(x) = Dx(f(x))\nf1 (generic function with 1 method)\n\njulia> expand_derivatives(f1(x))\n2x*cos(x^2)\n\njulia> Dy = Differential(y)\n(::Differential) (generic function with 2 methods)\n\njulia> expand_derivatives(Dx(Dy(cos(x*y))))\n-sin(x*y) - x*y*cos(x*y)\n\n\n\nPara calcular el vector gradiente de una función de varias variables se utiliza la siguiente función:\n\nSymbolics.gradient(f, vars): Devuelve el vector gradiente de la función f con respecto a las variables del vector vars.\n\nY para calcular la matriz Hessiana se utiliza la siguiente función:\n\nSymbolics.hessian(f, vars): Devuelve la matriz Hessiana de la función f con respecto a las variables del vector vars.\n\n\n\n\nusing Symbolics\n\n@variables x y;\n\njulia> Symbolics.gradient(exp(x*y), [x, y])\n2-element Vector{Num}:\n y*exp(x*y)\n x*exp(x*y)\n\njulia> Symbolics.hessian(exp(x*y), [x, y])\n2×2 Matrix{Num}:\n (y^2)*exp(x*y)               x*y*exp(x*y) + exp(x*y)\n   x*y*exp(x*y) + exp(x*y)  (x^2)*exp(x*y)"
  },
  {
    "objectID": "analisis-datos.html",
    "href": "analisis-datos.html",
    "title": "8  Análisis de datos",
    "section": "",
    "text": "El principal paquete para análisis de datos es DataFrames.jl que proporciona herramientas para trabajar con conjuntos de datos en formato de tabla de forma similar a pandas en Python o data.frames y dplyr en R.\nEn conjunción con este paquete es frecuente utilizar también alguno de los siguientes paquetes:\n\nFreqTables.jl. Funciones para la construcción de tablas de frecuencias.\nStatistics.jl. Funciones para los principales estadísticos descriptivos.\nHypothesisTests.jl Funciones para los contrastes de hipótesis paramétricos y no paramétricos más comunes.\nGLM.jl. Funciones para modelos lineales generales.\nMultivariateStats.jl. Funciones para análisis multivariante.\nMLJ.jl. Funciones para los principales algoritmos de aprendizaje automático.\n\n\n\nPara crear un DataFrame su utiliza la siguiente función:\n\nDataFrame(x1=v1, x2=v2, ...): Devuelve el DataFrame que formado por las columnas de los vectores v1, v2, etc, con los nombres x1, x2, etc, respectivamente.\n\nusing DataFrames\n\njulia> df = DataFrame(Nombre = [\"María\", \"Luis\", \"Carmen\"], Edad = [22, 18, 20])\n3×2 DataFrame\n Row │ Nombre  Edad  \n     │ String  Int64 \n─────┼───────────────\n   1 │ María      22\n   2 │ Luis       18\n   3 │ Carmen     20\n\n\n\nPara crear una DataFrame a partir de un fichero csv en la nube, se utiliza la siguiente función del paquete CSV.jl:\n\nCSV.read(download(url), DataFrame): Devuelve el DataFrame que resulta de importar el fichero csv con la url url.\n\nusing DataFrames, CSV\n\njulia> df = CSV.read(download(\"https://raw.githubusercontent.com/asalber/manual-python/master/datos/colesteroles.csv\"), DataFrame)\n14×6 DataFrame\n Row │ nombre                           edad   sexo     peso     altura   colesterol \n     │ String                           Int64  String1  Int64?   String7  Int64?     \n─────┼───────────────────────────────────────────────────────────────────────────────\n   1 │ José Luis Martínez Izquierdo        18  H             85  1,79            182\n   2 │ Rosa Díaz Díaz                      32  M             65  1,73            232\n   3 │ Javier García Sánchez               24  H        missing  1,81            191\n   4 │ Carmen López Pinzón                 35  M             65  1,70            200\n   5 │ Marisa López Collado                46  M             51  1,58            148\n   6 │ Antonio Ruiz Cruz                   68  H             66  1,74            249\n   7 │ Antonio Fernández Ocaña             51  H             62  1,72            276\n   8 │ Pilar Martín González               22  M             60  1,66        missing \n   9 │ Pedro Gálvez Tenorio                35  H             90  1,94            241\n  10 │ Santiago Reillo Manzano             46  H             75  1,85            280\n  11 │ Macarena Álvarez Luna               53  M             55  1,62            262\n  12 │ José María de la Guía Sanz          58  H             78  1,87            198\n  13 │ Miguel Angel Cuadrado Gutiérrez     27  H            109  1,98            210\n  14 │ Carolina Rubio Moreno               20  M             61  1,77            194"
  },
  {
    "objectID": "aplicaciones.html",
    "href": "aplicaciones.html",
    "title": "9  Otras aplicaciones",
    "section": "",
    "text": "JuliaGraphs. Graphs analysis in Julia."
  },
  {
    "objectID": "aplicaciones.html#cálculo-simbólico",
    "href": "aplicaciones.html#cálculo-simbólico",
    "title": "9  Otras aplicaciones",
    "section": "9.2 Cálculo simbólico",
    "text": "9.2 Cálculo simbólico\n\nSymPy. Sistema de Álgebra Computacional (CAS) basdado en la librería SymPy de Python.\nSymbolics Sistema de Álgebra Computacional (CAS) basado en Julia."
  },
  {
    "objectID": "aplicaciones.html#aprendizaje-automático",
    "href": "aplicaciones.html#aprendizaje-automático",
    "title": "9  Otras aplicaciones",
    "section": "9.3 Aprendizaje automático",
    "text": "9.3 Aprendizaje automático\n\nMLJ.jl. Funciones para los principales algoritmos de aprendizaje automático."
  }
]