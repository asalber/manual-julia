[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Manual de Julia",
    "section": "",
    "text": "Prefacio\n¬°Bienvenido al Manual de Julia!\nEste libro presenta una introducci√≥n al lenguaje de programaci√≥n Julia con un enfoque orientado al c√°lculo cient√≠fico y el an√°lisis de datos."
  },
  {
    "objectID": "index.html#licencia",
    "href": "index.html#licencia",
    "title": "Manual de Julia",
    "section": "Licencia",
    "text": "Licencia\nEsta obra est√° bajo una licencia Reconocimiento ‚Äì No comercial ‚Äì Compartir bajo la misma licencia 3.0 Espa√±a de Creative Commons. Para ver una copia de esta licencia, visite https://creativecommons.org/licenses/by-nc-sa/3.0/es/.\nCon esta licencia eres libre de:\n\nCopiar, distribuir y mostrar este trabajo.\nRealizar modificaciones de este trabajo.\n\nBajo las siguientes condiciones:\n\nReconocimiento. Debe reconocer los cr√©ditos de la obra de la manera especificada por el autor o el licenciador (pero no de una manera que sugiera que tiene su apoyo o apoyan el uso que hace de su obra).\nNo comercial. No puede utilizar esta obra para fines comerciales.\nCompartir bajo la misma licencia. Si altera o transforma esta obra, o genera una obra derivada, s√≥lo puede distribuir la obra generada bajo una licencia id√©ntica a √©sta.\n\nAl reutilizar o distribuir la obra, tiene que dejar bien claro los t√©rminos de la licencia de esta obra.\nEstas condiciones pueden no aplicarse si se obtiene el permiso del titular de los derechos de autor.\nNada en esta licencia menoscaba o restringe los derechos morales del autor."
  },
  {
    "objectID": "intro.html#por-qu√©-julia",
    "href": "intro.html#por-qu√©-julia",
    "title": "1¬† Introducci√≥n",
    "section": "1.1 ¬øPor qu√© Julia?",
    "text": "1.1 ¬øPor qu√© Julia?\nJulia es otro lenguaje de programaci√≥n m√°s, orientado a c√°lculo cient√≠fico el an√°lisis de datos similar a Python, R o Matlab.\n¬øDe veras necesitamos aprender otro lenguaje m√°s?"
  },
  {
    "objectID": "intro.html#qu√©-pretende-ser-julia",
    "href": "intro.html#qu√©-pretende-ser-julia",
    "title": "1¬† Introducci√≥n",
    "section": "1.2 ¬øQu√© pretende ser Julia?",
    "text": "1.2 ¬øQu√© pretende ser Julia?\nDe los creadores de Julia:\n\nWe want a language that is:\n\nOpen source.\nWith the speed of C.\nObvious, familiar mathematical notation like Matlab.\nAs usable for general programming as Python.\nAs easy for statistics as R.\nAs natural for string processing as Perl.\nAs powerful for linear algebra as Matlab.\nAs good at gluing programs together as the shell.\nDirt simple to learn, yet keeps the most serious hackers happy."
  },
  {
    "objectID": "intro.html#qu√©-es-julia",
    "href": "intro.html#qu√©-es-julia",
    "title": "1¬† Introducci√≥n",
    "section": "1.3 ¬øQu√© es Julia?",
    "text": "1.3 ¬øQu√© es Julia?\n\nJulia es un lenguaje de alto nivel con una sintaxis f√°cil de aprender (similar a Python, R o Matlab) que permite escribir s√≠mbolos matem√°ticos en las expresiones (UTF-8).\nJulia es un lenguaje muy veloz (equiparable a C en muchas tareas.)\nLenguaje din√°mico (tipado din√°mico y despacho m√∫ltiple).\nDe prop√≥sito general, pero orientado a la computaci√≥n cient√≠fica y el an√°lisis de grandes vol√∫menes de datos.\nCreado en 2019 en el MIT por el equipo del profesor Edelman.\n√öltima versi√≥n: 1.7 (bastante maduro).\nDesarrollado por una gran comunidad cient√≠fica.\nRepositorio de paquetes de c√≥digo abierto con m√°s de 3000 paquetes en dominios muy diversos.\n\n\n1.3.1 Comparativa de rapidez de Julia con otros lenguajes\n\n\n\nComparativa de Julia con otros lenguajes"
  },
  {
    "objectID": "intro.html#algunas-razones-m√°s-para-pens√°rselo",
    "href": "intro.html#algunas-razones-m√°s-para-pens√°rselo",
    "title": "1¬† Introducci√≥n",
    "section": "1.4 Algunas razones m√°s para pens√°rselo",
    "text": "1.4 Algunas razones m√°s para pens√°rselo\n\nEvita el problema de la doble reescritura de c√≥digo (prototipo + versi√≥n operativa).\nPermite la programaci√≥n paralela y distribuida.\nPuede ejecutar c√≥digo realizado en otros lenguajes como C, Fortran, Python, R, Matlab, etc."
  },
  {
    "objectID": "intro.html#instalaci√≥n-de-julia",
    "href": "intro.html#instalaci√≥n-de-julia",
    "title": "1¬† Introducci√≥n",
    "section": "1.5 Instalaci√≥n de Julia",
    "text": "1.5 Instalaci√≥n de Julia\n\nDescargar e instalar Julia.\nA√±adir Julia al PATH del sistema.\n\nUna vez instalado, para ejecutar el int√©rprete de Julia basta con abrir una terminal y teclear julia.\nprompt&gt; julia\n               _\n   _       _ _(_)_     |  Documentation: https://docs.julialang.org\n  (_)     | (_) (_)    |\n   _ _   _| |_  __ _   |  Type \"?\" for help, \"]?\" for Pkg help.\n  | | | | | | |/ _` |  |\n  | | |_| | | | (_| |  |  Version 1.7.3 (2022-05-06)\n _/ |\\__'_|_|_|\\__'_|  |  Official https://julialang.org/ release\n|__/                   |\n\njulia&gt;"
  },
  {
    "objectID": "intro.html#el-repl-de-julia",
    "href": "intro.html#el-repl-de-julia",
    "title": "1¬† Introducci√≥n",
    "section": "1.6 El REPL de Julia",
    "text": "1.6 El REPL de Julia\nEl REPL1 de Julia permite ejecutar c√≥digo de Julia tecle√°ndolo directamente en la terminal.\njulia&gt; 2 + 3\n5\nTiene, adem√°s, varios modos:\n\n; para abrir el modo shell.\n] para abrir el modo de gesti√≥n de paquetes.\n? para abrir el modoe de ayuda.to open help mode\n&lt;backspace&gt; para volver al modo normal."
  },
  {
    "objectID": "intro.html#el-gestor-de-paquetes-de-julia",
    "href": "intro.html#el-gestor-de-paquetes-de-julia",
    "title": "1¬† Introducci√≥n",
    "section": "1.7 El gestor de paquetes de Julia",
    "text": "1.7 El gestor de paquetes de Julia\nComo en otros lenguajes, es posible crear m√≥dulos o paquetes con c√≥digo que puede ser reutilizado. Julia tiene un potente gestor de paquetes que facilita la b√∫squeda, instalaci√≥n, actualizaci√≥n y eliminaci√≥n de paquetes.\nPor defecto el gestor de paquetes utiliza el repositorio de paquetes oficial pero se pueden instalar paquetes de otros repositorios.\nPara entrar en el modo de gesti√≥n de paquetes hay que teclear ]. Esto produce un cambio en el prompt del REPL de Julia.\nLos comandos m√°s habituales son:\n\nadd p: Instala el paquete p en el entorno activo de Julia.\nupdate: Actualiza los paquetes del entorno activo de Julia.\nstatus: Muestra los paquetes instalados y sus versiones en el entorno activo de Julia.\nremove p: Elimina el paquete p del entorno activo de Julia.\n\nEjemplo\n(@v1.7) pkg&gt; add CSV\n   Resolving package versions...\n   Installed CodecZlib ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ v0.7.0\n   Installed SentinelArrays ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ v1.3.13\n   Installed WeakRefStrings ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ v1.4.2\n   Installed InlineStrings ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ v1.1.4\n   Installed FilePathsBase ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ v0.9.18\n   Installed TranscodingStreams ‚îÄ v0.9.6\n   Installed CSV ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ v0.10.4\n    Updating `~/.julia/environments/v1.7/Project.toml`\n  [336ed68f] + CSV v0.10.4\n    Updating `~/.julia/environments/v1.7/Manifest.toml`\n  [336ed68f] + CSV v0.10.4\n  [944b1d66] + CodecZlib v0.7.0\n  [48062228] + FilePathsBase v0.9.18\n  [842dd82b] + InlineStrings v1.1.4\n  [91c51154] + SentinelArrays v1.3.13\n  [3bb67fe8] + TranscodingStreams v0.9.6\n  [ea10d353] + WeakRefStrings v1.4.2\nPrecompiling project..."
  },
  {
    "objectID": "intro.html#entornos-de-desarrollo",
    "href": "intro.html#entornos-de-desarrollo",
    "title": "1¬† Introducci√≥n",
    "section": "1.8 Entornos de desarrollo",
    "text": "1.8 Entornos de desarrollo\nCuando se trabaja en el desarrollo de varias aplicaciones, es habitual crear entornos de desarrollo individuales para instalar los paquetes de los que dependan y que no interfieran con los de otras aplicaciones.\nB√°sicamente, un entorno de desarrollo es un directorio con c√≥digo de Julia que contiene dos ficheros Project.toml y Manifest.toml que contienen los paquetes instalados en el entorno y sus dependencias.\nPara crear y activar un entorno de desarrollo se utilizan los siguiente comandos en el modo de gesti√≥n de paquetes:\n\ngenerate dir: Crea el directorio dir y lo convierte en un entorno de desarrollo de Julia.\nactivate dir: Convierte en el entorno de desarrollo dir en el entorno activo dentro de la sesi√≥n de Julia. A partir de entonces, cualquier paquete que se instale o actualice ser√° dentro de ese entorno.\n\nEjemplo\n(@v1.7) pkg&gt; generate app\n  Generating  project app:\n    app/Project.toml\n    app/src/app.jl\n\n(@v1.7) pkg&gt; activate app\n  Activating project at `~/app`\n\n(app) pkg&gt; add CSV # Instalar √∫ltima versi√≥n del paquete CSV\n...\n(app) pkg&gt; add DataFrames@v1.3.0;  # Instalar la versi√≥n 1.3.0 del paquete DataFrames\n...\n(app) pkg&gt; status\n     Project app v0.1.0\n      Status `~/app/Project.toml`\n  [336ed68f] CSV v0.10.4\n  [a93c6f00] DataFrames v1.3.0"
  },
  {
    "objectID": "intro.html#ides-para-julia",
    "href": "intro.html#ides-para-julia",
    "title": "1¬† Introducci√≥n",
    "section": "1.9 IDEs para Julia",
    "text": "1.9 IDEs para Julia\n\n\n1.9.1 Visual studio code\n\nDescargar e instalar VSCode.\nInstalar la extensi√≥n de Julia.\n\n\n\n\nVisual Studio Code con la extensi√≥n para Julia\n\n\n\n\n1.9.2 Jupyter\n\nDescargar e instalar Python\nDescargar e instalar Jupyter\nInstalar el paquete IJulia:\n\njulia&gt; using Pkg\njulia&gt; Pkg.add(\"IJulia\")\n\n\n\nJupyter con el kernel de Julia\n\n\n\n\n1.9.3 Pluto\nPluto es entorno de desarrollo propio de Julia similar a Jupyter. Pluto permite crear notebooks reactivos cuyas celdas se actualizan cada vez que se produce un cambio en el estado del programa.\nPara usarlo basta instalar el paquete Pluto.jl.\njulia&gt; using Pkg\n\njulia&gt; Pkg.add(\"Pluto\");\n\njulia&gt; using Pluto\n\njulia&gt; Pluto.run()\n[ Info: Loading...\n‚îå Info: \n‚îî Opening http://localhost:1234/?secret=a63iBsIL in your default browser... ~ have fun!\n‚îå Info: \n‚îÇ Press Ctrl+C in this terminal to stop Pluto\n‚îî \nOpening in existing browser session.\n\n\n\nP√°gina inicial de Pluto"
  },
  {
    "objectID": "intro.html#footnotes",
    "href": "intro.html#footnotes",
    "title": "1¬† Introducci√≥n",
    "section": "",
    "text": "REPL es el acr√≥nimo de Read, Evaluate, Print and Loop.‚Ü©Ô∏é"
  },
  {
    "objectID": "tipos-datos.html#tipos-de-datos-num√©ricos",
    "href": "tipos-datos.html#tipos-de-datos-num√©ricos",
    "title": "2¬† Tipos de datos y variables",
    "section": "2.1 Tipos de datos num√©ricos",
    "text": "2.1 Tipos de datos num√©ricos\n\nEnteros: Int64 (64 bits por defecto).\nRacionales: Rational{Int64}. Utilizando el operador //.\nReales: Float64 (64 bits por defecto).\nComplejos: Complex{Int64}. Utilizando im despu√©s de la parte imaginaria.\n\nPara averiguar el tipo de un dato se utiliza la funci√≥n typeof()."
  },
  {
    "objectID": "tipos-datos.html#ejemplos-de-tipos-de-datos-num√©ricos",
    "href": "tipos-datos.html#ejemplos-de-tipos-de-datos-num√©ricos",
    "title": "2¬† Tipos de datos y variables",
    "section": "2.2 Ejemplos de tipos de datos num√©ricos",
    "text": "2.2 Ejemplos de tipos de datos num√©ricos\njulia&gt; typeof(3)\nInt64\n\njulia&gt; typeof(3/2)\nFloat64\n\njulia&gt; typeof(3//2)\nRational{Int64}\n\njulia&gt; typeof(œÄ)\nIrrational{:œÄ}\n\njulia&gt; typeof(3+2im)\nComplex{Int64}"
  },
  {
    "objectID": "tipos-datos.html#jerarqu√≠a-de-tipos-de-datos-num√©ricos",
    "href": "tipos-datos.html#jerarqu√≠a-de-tipos-de-datos-num√©ricos",
    "title": "2¬† Tipos de datos y variables",
    "section": "2.3 Jerarqu√≠a de tipos de datos num√©ricos",
    "text": "2.3 Jerarqu√≠a de tipos de datos num√©ricos"
  },
  {
    "objectID": "tipos-datos.html#constantes-predefinidas",
    "href": "tipos-datos.html#constantes-predefinidas",
    "title": "2¬† Tipos de datos y variables",
    "section": "2.4 Constantes predefinidas",
    "text": "2.4 Constantes predefinidas\n\n\n\nS√≠mbolo\nDescripci√≥n\n\n\n\n\npi o œÄ\nN√∫mero irracional \\(\\pi\\)\n\n\n‚ÑØ (\\euler + TAB)\nN√∫mero irracional \\(e\\)\n\n\nInf\nInfinito\n\n\nNaN\nValor no num√©rico\n\n\nMissing\nValor desconocido"
  },
  {
    "objectID": "tipos-datos.html#ejemplo-de-constantes-predefinidas",
    "href": "tipos-datos.html#ejemplo-de-constantes-predefinidas",
    "title": "2¬† Tipos de datos y variables",
    "section": "2.5 Ejemplo de constantes predefinidas",
    "text": "2.5 Ejemplo de constantes predefinidas\njulia&gt; œÄ\nœÄ = 3.1415926535897...\n\njulia&gt; 1 / 0\nInf\n\njulia&gt; 0 / 0\nNaN\n\njulia&gt; Inf + Inf\nInf\n\njulia&gt; Inf - Inf\nNaN\n\njulia&gt; 0 * Inf\nNaN"
  },
  {
    "objectID": "tipos-datos.html#tipos-de-datos-alfanum√©ricos",
    "href": "tipos-datos.html#tipos-de-datos-alfanum√©ricos",
    "title": "2¬† Tipos de datos y variables",
    "section": "2.6 Tipos de datos alfanum√©ricos",
    "text": "2.6 Tipos de datos alfanum√©ricos\n\nCaracteres: Char. Se representan entre comillas simples.\nCadenas: String. Se representan entre comillas dobles.\n\njulia&gt; typeof('a')\nChar\n\njulia&gt; typeof(\"julia\")\nString\n\njulia&gt; typeof(\"a\")\nString"
  },
  {
    "objectID": "tipos-datos.html#tipo-de-datos-booleanos",
    "href": "tipos-datos.html#tipo-de-datos-booleanos",
    "title": "2¬† Tipos de datos y variables",
    "section": "2.7 Tipo de datos booleanos",
    "text": "2.7 Tipo de datos booleanos\n\nBooleanos: bool. Son un subtipo de los enteros Integer.\n\nSolo contienen dos posibles valores: true (1) y false (0).\njulia&gt; typeof(true)\nBool\n\njulia&gt; typeof(false)\nBool\n\njulia&gt; typeof(1 &lt; 2)\nBool\n\njulia&gt; true + true\n2"
  },
  {
    "objectID": "tipos-datos.html#variables",
    "href": "tipos-datos.html#variables",
    "title": "2¬† Tipos de datos y variables",
    "section": "2.8 Variables",
    "text": "2.8 Variables\nComo lenguaje de tipado din√°mico, no es necesario declarar una variable antes de usarla. Su tipo se infiere directamente del valor asociado.\njulia&gt; x = 1\n1\n\njulia&gt; typeof(x)\nInt64\n\njulia&gt; x = \"julia\"\n\"julia\"\n\njulia&gt; typeof(x)\nString\nNo obstante, para variables de √°mbito local, por ejemplo en funciones, es posible fijar el tipo de una variable indic√°ndolo detr√°s de su nombre con el operador ::.\nx::Int64"
  },
  {
    "objectID": "tipos-datos.html#nombres-de-variables",
    "href": "tipos-datos.html#nombres-de-variables",
    "title": "2¬† Tipos de datos y variables",
    "section": "2.9 Nombres de variables",
    "text": "2.9 Nombres de variables\nJulia reconoce la codificaci√≥n Unicode (UTF-8), lo que permite utilizar caracteres con tildes, letras griegas, s√≠mbolos matem√°ticos y hasta emoticonos en los nombres de variables o funciones. Para ello se utilizan c√≥digos especiales (en muchos casos son los mismos que en LaTeX), pulsando despu√©s la tecla de tabulaci√≥n.\njulia&gt; Œ± = 1\n1\n\njulia&gt; Œ≤ = 2\n2\n\njulia&gt; Œ± + Œ≤\n3\n\njulia&gt; üòÑ = \"julia\"\n\"julia\"\nDistingue entre may√∫sculas y min√∫sculas.\n\n2.9.1 Caracteres Unicode\nLa siguiente tabla contiene algunos caracteres Unicode habituales\n\n\n\n\n\n\n\n\nC√≥digo\nS√≠mbolo\nUso notes\n\n\n\n\n\\euler\n‚ÑØ\nConstante de Euler e\n\n\n\\pi\nœÄ\nConstante \\(pi\\)\n\n\n\\alpha\nŒ±\n\n\n\n\\beta\nŒ≤\n\n\n\n\\delta\nŒ¥\n\n\n\n\\Delta\nŒî\nVariaci√≥n\n\n\n\\gamma\nŒ≥\n\n\n\n\\phi\nœï\n\n\n\n\\Phi\nŒ¶\n\n\n\nx\\_1\nx‚ÇÅ\nSub√≠ndices\n\n\nx\\^2\nx¬≤\nSuper√≠ndices\n\n\nr\\vec\nr‚Éó\nNotaci√≥n para vectores\n\n\nT\\hat\nTÃÇ\nNotaci√≥n para vectores unitarios\n\n\n\\partial\n‚àÇ\nNotaci√≥n para derivadas parciales\n\n\n\\nabla\n‚àá\nNotaci√≥n para el gradiente\n\n\n\\circ\n‚àò\nOperador de composici√≥n\n\n\n\\cdot\n‚ãÖ\nOperador de producto escalar\n\n\n\\times\n√ó\nOperador de producto vectorial\n\n\n\nLos operadores pueden necesitar par√©ntesis, como por ejemplo (f ‚àò g)(x) para la composici√≥n de g con f."
  },
  {
    "objectID": "tipos-datos.html#operadores-aritm√©ticos",
    "href": "tipos-datos.html#operadores-aritm√©ticos",
    "title": "2¬† Tipos de datos y variables",
    "section": "2.10 Operadores aritm√©ticos",
    "text": "2.10 Operadores aritm√©ticos\n\n\n\nOperador\nDescripci√≥n\n\n\n\n\nx + y\nSuma\n\n\nx - y\nResta\n\n\nx * y\nProducto\n\n\nx / y\nDivisi√≥n\n\n\nx √∑ y\nCociente divisi√≥n entera\n\n\nx % y\nResto divisi√≥n entera\n\n\nx ^ y\nPotencia"
  },
  {
    "objectID": "tipos-datos.html#operadores-de-comparaci√≥n",
    "href": "tipos-datos.html#operadores-de-comparaci√≥n",
    "title": "2¬† Tipos de datos y variables",
    "section": "2.11 Operadores de comparaci√≥n",
    "text": "2.11 Operadores de comparaci√≥n\n\n\n\nOperador\nDescripci√≥n\n\n\n\n\n==\nIgualdad\n\n\n!=, ‚â†\nDesigualdad\n\n\n&lt;\nMenor que\n\n\n&lt;=, ‚â§\nMenor o igual que\n\n\n&gt;\nMayor que\n\n\n&gt;=, ‚â•\nMayor o igual que"
  },
  {
    "objectID": "tipos-datos.html#operadores-booleanos",
    "href": "tipos-datos.html#operadores-booleanos",
    "title": "2¬† Tipos de datos y variables",
    "section": "2.12 Operadores booleanos",
    "text": "2.12 Operadores booleanos\n\n\n\nOperador\nDescripci√≥n\n\n\n\n\n!x\nNegaci√≥n\n\n\nx && y\nConjunci√≥n (y)\n\n\nx || y\nDisyunci√≥n (o)"
  },
  {
    "objectID": "tipos-datos.html#funciones-num√©ricas-predefinidas",
    "href": "tipos-datos.html#funciones-num√©ricas-predefinidas",
    "title": "2¬† Tipos de datos y variables",
    "section": "2.13 Funciones num√©ricas predefinidas",
    "text": "2.13 Funciones num√©ricas predefinidas\n\n2.13.1 Funciones de redondeo\n\n\n\n\n\n\n\nFunci√≥n\nDescripci√≥n\n\n\n\n\nround(x)\nDevuelve el entero m√°s pr√≥ximo a x\n\n\nround(x, digits = n)\nDevuelve al valor m√°s pr√≥ximo a x con n decimales\n\n\nfloor(x)\nRedondea x al pr√≥ximo entero menor\n\n\nceil(x)\nRedondea x al pr√≥ximo entero mayor\n\n\ntrunc(x)\nDevuelve la parte entera de x\n\n\n\n\n\n2.13.2 Ejemplo de funciones de redondeo\njulia&gt; round(2.7)\n3.0\n\njulia&gt; floor(2.7)\n2.0\n\njulia&gt; floor(-2.7)\n-3.0\n\njulia&gt; ceil(2.7)\n3.0\n\njulia&gt; ceil(-2.7)\n-2.0\n\njulia&gt; trunc(2.7)\n2.0\n\njulia&gt; trunc(-2.7)\n-2.0\n\njulia&gt; round(2.5)\n2.0\n\njulia&gt; round(2.786, digits = 2)\n2.79\n\n\n2.13.3 Funciones de divisi√≥n\n\n\n\n\n\n\n\nFunci√≥n\nDescripci√≥n\n\n\n\n\ndiv(x,y), x√∑y\nCociente de la divisi√≥n entera\n\n\nfld(x,y)\nCociente de la divisi√≥n entera redondeado hacia abajo\n\n\ncld(x,y)\nCociente de la divisi√≥n entera redondeado hacia arriba\n\n\nrem(x,y), x%y\nResto de la divisi√≥n entera. Se cumple x == div(x,y)*y + rem(x,y)\n\n\nmod(x,y)\nM√≥dulo con respecto a y. Se cumple x == fld(x,y)*y + mod(x,y)\n\n\ngcd(x,y...)\nM√°ximo com√∫n divisor positivo de x, y,‚Ä¶\n\n\nlcm(x,y...)\nM√≠nimo com√∫n m√∫ltiplo positivo de x, y,‚Ä¶\n\n\n\n\n\n2.13.4 Ejemplo de funciones de divisi√≥n\njulia&gt; div(5,3)\n1\n\njulia&gt; cld(5,3)\n2\n\njulia&gt; 5%3\n2\n\njulia&gt; -5%3\n-2\n\njulia&gt; mod(5,3)\n2\n\njulia&gt; mod(-5,3)\n1\n\njulia&gt; gcd(12,18)\n6\n\njulia&gt; lcm(12,18)\n36\n\n\n2.13.5 Funciones para el signo y el valor absoluto\n\n\n\n\n\n\n\nFunci√≥n\nDescripci√≥n\n\n\n\n\nabs(x)\nValor absoluto de x\n\n\nsign(x)\nDevuelve 1 si x es positivo, -1 si es negativo y 0 si es 0.\n\n\n\njulia&gt; abs(2.5)\n2.5\n\njulia&gt; abs(-2.5)\n2.5\n\njulia&gt; sign(-2.5)\n-1.0\n\njulia&gt; sign(0)\n0\n\njulia&gt; sign(2.5)\n1.0\n\n\n2.13.6 Ra√≠ces, exponenciales y logaritmos\n\n\n\n\n\n\n\nFunci√≥n\nDescripci√≥n\n\n\n\n\nsqrt(x), ‚àöx\nRa√≠z cuadrada de x\n\n\ncbrt(x), ‚àõx\nRa√≠z c√∫bica de x\n\n\nexp(x)\nExponencial de x\n\n\nlog(x)\nLogaritmo neperiano de x\n\n\nlog(b,x)\nLogaritmo en base b de x\n\n\nlog2(x)\nLogaritmo en base 2 de x\n\n\nlog10(x)\nLogaritmo en base 10 de x\n\n\n\n\n\n2.13.7 Ejemplo de ra√≠ces, exponenciales y logaritmos\njulia&gt; sqrt(4)\n2.0\n\njulia&gt; cbrt(27)\n3.0\n\njulia&gt; exp(1)\n2.718281828459045\n\njulia&gt; exp(-Inf)\n0.0\n\njulia&gt; log(1)\n0.0\n\njulia&gt; log(0)\n-Inf\n\njulia&gt; log(-1)\nERROR: DomainError with -1.0:\nlog will only return a complex result if called with a complex argument.\n...\n\njulia&gt; log(-1+0im)\n0.0 + 3.141592653589793im\n\njulia&gt; log2(2^3)\n3.0\n\n\n2.13.8 Funciones trigonom√©tricas\n\n\n\n\n\n\n\nFunci√≥n\nDescripci√≥n\n\n\n\n\nhypot(x,y)\nHipotenusa del tri√°ngulo rect√°ngulo con catetos x e y\n\n\nsin(x)\nSeno del √°ngulo x en radianes\n\n\nsind(x)\nSeno del √°ngulo x en grados\n\n\ncos(x)\nCoseno del √°ngulo x en radianes\n\n\ncosd(x)\nCoseno del √°ngulo x en grados\n\n\ntan(x)\nTangente del √°ngulo x en radianes\n\n\ntand(x)\nTangente del √°ngulo x en grados\n\n\nsec(x)\nSecante del √°ngulo x en radianes\n\n\ncsc(x)\nCosecante del √°ngulo x en radianes\n\n\ncot(x)\nCotangente del √°ngulo x en radianes\n\n\n\n\n\n2.13.9 Ejemplo de funciones trigonom√©tricas\njulia&gt; sin(œÄ/2)\n1.0\n\njulia&gt; cos(œÄ/2)\n6.123233995736766e-17\n\njulia&gt; cosd(90)\n0.0\n\njulia&gt; tan(œÄ/4)\n0.9999999999999999\n\njulia&gt; tand(45)\n1.0\n\njulia&gt; tan(œÄ/2)\n1.633123935319537e16\n\njulia&gt; tand(90)\nInf\n\njulia&gt; sin(œÄ/4)^2 + cos(œÄ/4)^2\n1.0\n\n\n2.13.10 Funciones trigonom√©tricas inversas\n\n\n\n\n\n\n\nFunci√≥n\nDescripci√≥n\n\n\n\n\nasin(x)\nArcoseno (inversa del seno) de x en radianes\n\n\nasind(x)\nArcoseno (inversa del seno) de x en grados\n\n\nacos(x)\nArcocoseno (inversa del coseno) de x en radianes\n\n\nacosd(x)\nArcocoseno (inversa del coseno) de x en grados\n\n\natan(x)\nArcotangente (inversa de la tangente) de x en radianes\n\n\natand(x)\nArcotangente (inversa de la tangente) de x en grados\n\n\nasec(x)\nArcosecante (inversa de la secante) de x en radianes\n\n\nacsc(x)\nArcocosecante (inversa de la cosecante) de x en radianes\n\n\nacot(x)\nArcocotangente (inversa de la cotangente) de x en radianes\n\n\n\n\n\n2.13.11 Ejemplo de funciones trigonom√©tricas inversas\njulia&gt; asin(1)\n1.5707963267948966\n\njulia&gt; asind(1)\n90.0\n\njulia&gt; acos(-1)\n3.141592653589793\n\njulia&gt; atan(1)\n0.7853981633974483\n\njulia&gt; atand(tan(œÄ/4))\n45.0"
  },
  {
    "objectID": "tipos-datos.html#precedencia-de-operadores",
    "href": "tipos-datos.html#precedencia-de-operadores",
    "title": "2¬† Tipos de datos y variables",
    "section": "2.14 Precedencia de operadores",
    "text": "2.14 Precedencia de operadores\nDe mayor a menor prioridad.\n\n\n\n\n\n\n\n\nCategor√≠a\nOperadores\nAsociatividad\n\n\n\n\nExponenciaci√≥n\n^\nDerecha\n\n\nUnarios\n+ - ‚àö\nDerecha\n\n\nFracciones\n//\nIzquierda\n\n\nMultiplicaci√≥n\n* / % & \\ √∑\nIzquierda\n\n\nAdici√≥n\n+ - |\nIzquierda\n\n\nComparaciones\n&gt; &lt; &gt;= &lt;= == != !==\n\n\n\nAsignaciones\n= += -= *= /= //= ^= √∑= %= |= &=\nDerecha"
  },
  {
    "objectID": "tipos-datos.html#operaciones-con-cadenas",
    "href": "tipos-datos.html#operaciones-con-cadenas",
    "title": "2¬† Tipos de datos y variables",
    "section": "2.15 Operaciones con cadenas",
    "text": "2.15 Operaciones con cadenas\nLas cadenas son secuencias de caracteres alfanum√©ricos del tipo char entre dobles comillas.\nCada car√°cter tiene asociado un √≠ndice entero. El primer car√°cter de la cadena tiene √≠ndice 1.\n\n\n\n√çndice\n1\n2\n3\n4\n5\n\n\nCadena\nj\nu\nl\ni\na\n\n\n\nPodemos acceder a cada car√°cter usando su √≠ndice entre corchetes a continuaci√≥n de la cadena:\n\ns[i]: Devuelve el car√°cter con √≠ndice i en la cadena s.\n\njulia&gt; c = \"julia\"\n\"julia\"\n\njulia&gt; c[2]\n'u': ASCII/Unicode U+0075 (category Ll: Letter, lowercase)\n\n2.15.1 Acceso a caracteres Unicode\nSin embargo, como Julia permite caracteres Unicode, el √≠ndice de un car√°cter en una cadena, no siempre se corresponde con su posici√≥n en la cadena. Ello es debido a que la codificaci√≥n UTF-8 no utiliza el mismo n√∫mero de bytes para representar los caracteres Unicode. Mientras que los caracteres habituales del c√≥digo ASCII (letras romanas y n√∫meros √°rabes) solo necesitan un byte, otros caracteres como los s√≠mbolos matem√°ticos requieren m√°s.\n\n\n\n√çndice\n1\n4\n5\n6\n9\n\n\nCadena\n‚àÄ\nx\n\n‚àÉ\ny\n\n\n\n\n\n2.15.2 Ejemplo de acceso a caracteres Unicode\njulia&gt; c = \"‚àÄx ‚àÉy\"\n\"‚àÄx ‚àÉy\"\n\njulia&gt; c[1]\n'‚àÄ': Unicode U+2200 (category Sm: Symbol, math)\n\njulia&gt; c[2]\nERROR: StringIndexError: invalid index [2], \nvalid nearby indices [1]=&gt;'‚àÄ', [4]=&gt;'x'\nStacktrace:\n [1] string_index_err(s::String, i::Int64)\n   @ Base ./strings/string.jl:12\n [2] getindex_continued(s::String, i::Int64, u::UInt32)\n   @ Base ./strings/string.jl:233\n [3] getindex(s::String, i::Int64)\n   @ Base ./strings/string.jl:226\n [4] top-level scope\n   @ REPL[128]:1\n\n\n2.15.3 Acceso a √≠ndices en cadenas\nLas siguientes funciones permiten acceder a los √≠ndices de una cadena:\n\nfirstindex(c): Devuelve el √≠ndice del primer car√°cter de la cadena c.\nlastindex(c): Devuelve el √≠ndice del primer car√°cter de la cadena c.\nnextind(c, i): Devuelve el √≠ndice del car√°cter de la cadena c que sigue al car√°cter con √≠ndice i.\nprevind(c, i): Devuelve el √≠ndice del car√°cter de la cadena c que sigue al car√°cter con √≠ndice i.\n\n\n\n2.15.4 Ejemplo de acceso a √≠ndices en cadenas\njulia&gt; firstindex(c)\n1\n\njulia&gt; lastindex(c)\n9\n\njulia&gt; c[9]\n'y': ASCII/Unicode U+0079 (category Ll: Letter, lowercase)\n\njulia&gt; nextind(c,1)\n4\n\njulia&gt; prevind(c, lastindex(c))\n6\n\n\n2.15.5 Subcadenas\nPara obtener subcadenas se usan tambi√©n los corchetes indicando los √≠ndices de inicio y fin separados por :.\n\ns[i:j]: Devuelve la subcadena que va desde el √≠ndice i al √≠ndice j, ambos incluidos.\n\nTambi√©n se pueden obtener subcadenas con la siguiente funci√≥n:\n\nSubString(s, i, j): Devuelve la subcadena que va desde el √≠ndice i al √≠ndice j, ambos incluidos.\n\njulia&gt; c = \"julia\"\n\"julia\"\n\njulia&gt; c[2:4]\n\"uli\"\n\njulia&gt; SubString(c, 2, 4)\n\"uli\""
  },
  {
    "objectID": "tipos-datos.html#concatenaci√≥n-de-cadenas",
    "href": "tipos-datos.html#concatenaci√≥n-de-cadenas",
    "title": "2¬† Tipos de datos y variables",
    "section": "2.16 Concatenaci√≥n de cadenas",
    "text": "2.16 Concatenaci√≥n de cadenas\n\na * b: Devuelve la cadena que resulta de concatenar las cadenas a y b.\na ^ i: Devuelve la cadena que resulta de repetir la cadena a el n√∫mero de veces i.\nrepeat(a, i): Devuelve la cadena que resulta de repetir la cadena a el n√∫mero de veces i.\n\njulia&gt; a = \"Hola\"\n\"Hola\"\n\njulia&gt; b = \"Julia\"\n\"Julia\"\n\njulia&gt; a * b\n\"HolaJulia\"\n\njulia&gt; b ^ 3\n\"JuliaJuliaJulia\"\n\n2.16.1 Interpolaci√≥n de cadenas\nEn una cadena se pueden introducir variables o expresiones precedidas del s√≠mbolo $, de manera que al evaluarlas julia sustituye la variable o expresi√≥n por su valor. Esto es muy util para formatear salidas.\njulia&gt; \"1 + 2 = $(1 + 2)\"\n\"1 + 2 = 3\"\n\njulia&gt; s = \"Julia\"\n\"Julia\"\n\njulia&gt; \"Hola $s\"\n\"Hola Julia\"\n\n\n2.16.2 Otras operaciones comunes con cadenas\n\nlength(c): Devuelve el n√∫mero de caracteres de la cadena c.\nfindfirst(a, c): Devuelve el √≠ndice de la primera ocurrencia de la cadena a en la cadena c. Si a no es una subcadena de c devuelve nada (tipo Nothing).\nfindlast(a, c): Devuelve el √≠ndice de la √∫ltima ocurrencia de la cadena a en la cadena c. Si a no es una subcadena de c devuelve nada (tipo Nothing).\nfindnext(a, c, i): Devuelve el √≠ndice de la primera ocurrencia de la cadena a en la cadena c posterior al √≠ndice i.\nfindprev(a, c, i): Devuelve el √≠ndice de la √∫ltima ocurrencia de la cadena a en la cadena c anterior al √≠ndice i.\n\n\n\n2.16.3 Otras operaciones comunes con cadenas\n\noccursin(a, c): Devuelve true si la cadena a es una subcadena de c, y false en caso contrario.\ncontains(c, a): Devuelve true si la cadena a es una subcadena de c, y false en caso contrario.\nreplace(c, a =&gt; b): Devuelve la cadena que resulta de sustituir la cadena a por la b en la cadena c.\nlowercase(c): Devuelve la cadena c en min√∫sculas.\nuppercase(c): Devuelve la cadena c en may√∫sculas.\nprefix(c, a): Devuelve true si la cadena a es un prefijo de la cadena c.\nsuffix(c, a): Devuelve true si la cadena a es un sufijo de la cadena c.\nsplit(c, a): Devuelve una lista con las cadenas que resulpan de partir la cadena c por el delimitador a.\n\n\n\n2.16.4 Ejemplo de otras operaciones con cadenas\njulia&gt; c = \"Hola Julia\"\n\"Hola Julia\"\n\njulia&gt; length(c)\n10\n\njulia&gt; findfirst(\"a\", c) \n4:4\n\njulia&gt; findlast(\"Ju\", c)\n6:7\n\njulia&gt; findlast(\"x\", c)\n\njulia&gt; occursin(\"Julia\", c)\ntrue\n\njulia&gt; occursin(\"julia\", c)\nfalse\n\njulia&gt; replace(c, \"a\" =&gt; \"o\")\n\"Holo Julio\"\n\njulia&gt; uppercase(c)\n\"HOLA JULIA\"\n\njulia&gt; split(c, \" \")\n2-element Vector{SubString{String}}:\n \"Hola\"\n \"Julia\""
  },
  {
    "objectID": "tipos-datos.html#entrada-y-salida-por-terminal",
    "href": "tipos-datos.html#entrada-y-salida-por-terminal",
    "title": "2¬† Tipos de datos y variables",
    "section": "2.17 Entrada y salida por terminal",
    "text": "2.17 Entrada y salida por terminal\nLas siguientes funciones muestran una cadena en la terminal:\n\nprint(c): Muestra por la terminal la cadena c sin cambiar de l√≠nea.\nprintln(c): Muestra por la terminal la cadena c y cambia de l√≠nea.\n\nLa siguiente funci√≥n permite leer una l√≠nea de texto desde la terminal:\n\nreadline(): Devuelve en una cadena una l√≠nea de texto introducida por el usuario en la terminal (hasta el car√°cter de cambio de l√≠nea \\n)\n\njulia&gt; print(\"¬øC√≥mo te llamas?\")\n¬øC√≥mo te llamas?\njulia&gt; nombre = readline()\nAlf            \n\"Alf\"\n\njulia&gt; println(\"Hola $nombre\")\nHola Alf\n\n2.17.1 Conversi√≥n de cadenas en n√∫meros\nLa funci√≥n readline() siempre devuelve una cadena a√∫n cuando se pregunte al usuario por un valor num√©rico. Para convertir una cadena en un dato num√©rico se utiliza la siguiente funci√≥n:\n\nparse(tipo, c): Covierte la cadena c a un n√∫mero del tipo num√©rico tipo, siempre que puedad realizarse la conversi√≥n.\n\njulia&gt; print(\"Introduce tu edad\")\nIntroduce tu edad\njulia&gt; edad = parse(Int, readline())\n18\n18\n\njulia&gt; println(\"Vas a cumplir $(edad + 1) a√±os\")\nVas a cumplir 19 a√±os\n\njulia&gt; typeof(edad)\nInt64"
  },
  {
    "objectID": "estructuras-control.html#condicionales",
    "href": "estructuras-control.html#condicionales",
    "title": "3¬† Estructuras de control",
    "section": "3.1 Condicionales",
    "text": "3.1 Condicionales\n\nif condici√≥n 1\n¬†¬†¬†bloque c√≥digo 1\nelseif condici√≥n 2\n¬†¬†¬†bloque c√≥digo 2\n‚Ä¶\nelse\n¬†¬†¬†bloque c√≥digo n\nend\n\nLa indentaci√≥n de los bloques de c√≥digo no es necesaria, pero es una buena pr√°ctica.\n\n3.1.1 Ejemplo de condicional\njulia&gt; x = -1\n-1\n\njulia&gt; if x &gt; 0\n         signo = \"positivo\"\n       elseif x &lt; 0\n         signo = \"negativo\"\n       else\n         signo = \"nulo\"\n       end\n\"negativo\"\n\n\n3.1.2 Operador condicional\nUna forma abreviada de la estructura condicional es el operador condicional.\n\ncondici√≥n ? bloque true : bloque false\n\nEste operador ejecuta el primer bloque de c√≥digo si la condici√≥n es true y el segundo en caso contrario.\njulia&gt; x &gt; 0 ? signo = \"positivo\" : signo = \"negativo\"\n\"negativo\""
  },
  {
    "objectID": "estructuras-control.html#bucles",
    "href": "estructuras-control.html#bucles",
    "title": "3¬† Estructuras de control",
    "section": "3.2 Bucles",
    "text": "3.2 Bucles"
  },
  {
    "objectID": "estructuras-control.html#bucles-iterativos",
    "href": "estructuras-control.html#bucles-iterativos",
    "title": "3¬† Estructuras de control",
    "section": "3.3 Bucles iterativos",
    "text": "3.3 Bucles iterativos\n\nfor iterador in secuencia\n¬†¬†¬†bloque c√≥digo\nend\n\nEjecuta el bloque de c√≥digo tantas veces como elementos tenga la secuencia. En cada iteraci√≥n el iterador toma como valor el siguiente elemento de la secuencia.\njulia&gt; c = \"Julia\"\n\"Julia\"\n\njulia&gt; for i in c\n         println(i)\n       end\nJ\nu\nl\ni\na\n\n3.3.1 Bucles iterativos con rangos\nEn muchas ocasiones la secuencia que se recorre en un bucle iterativo se genera mediante un rango, que es una secuencia de n√∫meros igualmente espaciados. Existen distintas funciones para generar rangos:\n\ni:j: Genera la secuenciad de n√∫meros desde i hasta j.\ni:j:k: Genera la secuencia de n√∫meros desde i hasta k dando saltos de j.\nStepRange(i, j, k): Genera la secuencia de n√∫meros desde i hasta k dando saltos de j.\nrange(i, j, n): Genera una secuencia de n n√∫meros desde i hasta j.\n\n\n\n3.3.2 Ejemplo de bucles iterativos con rangos\njulia&gt; for i in 1:2:10\n         println(i)\n       end\n1\n3\n5\n7\n9\n\njulia&gt; for i = range(0, 10, 5)\n         println(i)\n       end\n0.0\n2.5\n5.0\n7.5\n10.0\n\n\n3.3.3 Bucles iterativos anidados\nEn muchas ocasiones es habitual incluir un bucle iterativo en el bloque de c√≥digo de otro bucle iterativo, lo que se conoce como bucles anidados.\nJulia permite simplificar estas estructuras indicando los iteradores en la cabecera de un √∫nico bucle.\njulia&gt; for i in \"abc\", j = 1:2\n         println(i,j)\n       end\na1\na2\nb1\nb2\nc1\nc2"
  },
  {
    "objectID": "estructuras-control.html#bucles-condicionales",
    "href": "estructuras-control.html#bucles-condicionales",
    "title": "3¬† Estructuras de control",
    "section": "3.4 Bucles condicionales",
    "text": "3.4 Bucles condicionales\n\nwhile condici√≥n\n¬†¬†¬†bloque c√≥digo\nend\n\nRepite la ejecuci√≥n del bloque de c√≥digo mientras que la condici√≥n sea cierta.\njulia&gt; x = 3\n3\n\njulia&gt; while x &gt;= 0\n          println(x)\n          x -= 1\n       end\n3\n2\n1\n0\n\n3.4.1 Interrupci√≥n de bucles\nLa instrucci√≥n break provoca inmediatamente la finalizaci√≥n de un bucle tanto iterativo como condicional.\njulia&gt; x=3\n3\n\njulia&gt; while true\n          if x &lt; 0 \n             break\n          end\n          println(x)\n          x -= 1\n       end\n3\n2\n1\n0\n\n\n3.4.2 Salto de bucles\nLa instrucci√≥n continue provoca la finalizaci√≥n del bloque de c√≥digo de un bucle y pasa inmediatamente a la siguiente iteraci√≥n.\njulia&gt; for i in 1:10\n          if i % 2 == 0\n             continue\n          end\n          println(i)\n       end\n1\n3\n5\n7\n9"
  },
  {
    "objectID": "tipos-datos-compuestos.html#colecciones-de-datos",
    "href": "tipos-datos-compuestos.html#colecciones-de-datos",
    "title": "4¬† Tipos de datos compuestos",
    "section": "4.1 Colecciones de datos",
    "text": "4.1 Colecciones de datos\nColecciones de datos con distinta estructura y sem√°ntica.\n\nArrays\n\nVectores\nMatrices\n\nTuplas\nDiccionarios\nConjuntos"
  },
  {
    "objectID": "tipos-datos-compuestos.html#arrays",
    "href": "tipos-datos-compuestos.html#arrays",
    "title": "4¬† Tipos de datos compuestos",
    "section": "4.2 Arrays",
    "text": "4.2 Arrays\nUn array es una colecci√≥n ordenada de datos de un mismo tipo.\nEl tipo del array se infiere autom√°ticamente a partir de los tipos de sus elementos. Si los elementos son de distintos tipos se convierten al tipo m√°s espec√≠fico de la jerarqu√≠a de tipos del que los tipos de los elementos son subtipos.\nSe construyen escribiendo sus elementos separados por comas, puntos y comas o espacios entre corchetes.\njulia&gt; [1, 2, 3]\n3-element Vector{Int64}:\n 1\n 2\n 3\n\njulia&gt; [1.0, \"julia\", true]\n3-element Vector{Any}:\n    1.0\n     \"julia\"\n true"
  },
  {
    "objectID": "tipos-datos-compuestos.html#arrays-multidimensionales",
    "href": "tipos-datos-compuestos.html#arrays-multidimensionales",
    "title": "4¬† Tipos de datos compuestos",
    "section": "4.3 Arrays multidimensionales",
    "text": "4.3 Arrays multidimensionales\nLos arrays pueden estructurar sus elementos en m√∫ltiples dimensiones. Dependiendo el n√∫mero de dimensiones tenemos distintos tipos de arrays:\n\n\n4.3.1 Funciones de arrays\n\nlength(A): Devuelve el n√∫mero de elementos del array A.\neltype(A): Devuelve el tipo de los elementos del array A.\nndims(A): Devuelve el n√∫mero de dimensiones del array A.\nsize(A): Devuelve una tupla con los tama√±os de las dimensiones del array A.\nsize(A, n): Devuelve el tama√±o de la dimensi√≥n n del array A.\naxes(A): Devuelve una tupla con los √≠ndices v√°lidos de cada dimensi√≥n del array A.\naxes(A, n): Devuelve un rango con los √≠ndices v√°lidos de la dimensi√≥n n del array A.\neachindex(A): Devuelve un iterador sobre los √≠ndices de los elementos del array A.\n\n\n\n4.3.2 Constructores de arrays\n\nzeros(dim): Devuelve un array de la dimensiones indicadas por la tupla dim con todos sus elementos ceros.\nones(dim): Devuelve un array de la dimensiones indicadas por la tupla dim con todos sus elementos unos.\nfill(a, dim): Devuelve un array de la dimensiones indicadas por la tupla dim con todos sus elementos iguales a.\nrand(dim): Devuelve un array de la dimensiones indicadas por la tupla dim con todos sus elementos n√∫meros aleatorios entre 0 y 1.\ntrues(dim): Devuelve un array de la dimensiones indicadas por la tupla dim con todos sus elementos true.\nfalses(dim): Devuelve un array de la dimensiones indicadas por la tupla dim con todos sus elementos false.\n\n\n\n4.3.3 Ejemplos de constructores de arrays\njulia&gt; zeros(3)  # Vector de tama√±o 3\n3-element Vector{Float64}:\n 0.0\n 0.0\n 0.0\n\njulia&gt; rand(3,2)  # Matriz de tama√±o 3 x 2\n3√ó2 Matrix{Float64}:\n 0.1469    0.891839\n 0.953462  0.395681\n 0.819468  0.720606\n\njulia&gt; fill(œÄ, 2, 2)\n2√ó2 Matrix{Irrational{:œÄ}}:\n œÄ  œÄ\n œÄ  œÄ\n\n\n4.3.4 Redimensionamiento de arrays\nLa siguientes funciones permiten cambiar las dimensiones de un array, reestructurando sus elementos:\n\nreshape(A, dim): Devuelve el array que resulta de redimiensionar el array A con las dimensiones indicadas por la tupla dim.\npermutedims(A): Devuelve el array de resulta de trasponer el array A.\n\n\n\n\n\n\n\nAdvertencia\n\n\n\nEl array resultante debe tener los mismos elementos que el array original, por lo que si las dimensiones no son compatibles se produce un error.\n\n\n\n\n4.3.5 Ejemplo de redimensionamiento de arrays\njulia&gt; v = [1, 2, 3, 4, 5, 6]\n6-element Vector{Int64}:\n 1\n 2\n 3\n 4\n 5\n 6\n\njulia&gt; reshape(v, 2, 3)\n2√ó3 Matrix{Int64}:\n 1  3  5\n 2  4  6\n\njulia&gt; reshape(v, 3, 2)\n3√ó2 Matrix{Int64}:\n 1  4\n 2  5\n 3  6\n\njulia&gt; permutedims(reshape(v, 3, 2))\n2√ó3 Matrix{Int64}:\n 1  2  3\n 4  5  6\n\n\n4.3.6 Comprensi√≥n de arrays\nUna potente t√©cnica de creaci√≥n de arrays es la comprensi√≥n de arrays, que consiste en generar los elementos del array a partir de uno o varios iteradores.\n\n[exp for i = ite]: Devuelve el vector cuyos elementos resultan de evaluar a expresi√≥n exp para cada valor i del iterador ite.\n[exp for i = ite if cond]: Devuelve el vector cuyos elementos resultan de evaluar a expresi√≥n exp para cada valor i del iterador ite que cumpla la condici√≥n cond.\n\nSe pueden utilizar varios iteradores para crear arrays de varias dimensiones.\njulia&gt; [i^2 for i = 1:4]\n4-element Vector{Int64}:\n  1\n  4\n  9\n 16\n\njulia&gt; [i^2 for i = 1:4 if i % 2 == 0]\n2-element Vector{Int64}:\n  4\n 16\n\njulia&gt; [i+j for i = 1:2, j = 3:4]\n2√ó2 Matrix{Int64}:\n 4  5\n 5  6"
  },
  {
    "objectID": "tipos-datos-compuestos.html#vectores",
    "href": "tipos-datos-compuestos.html#vectores",
    "title": "4¬† Tipos de datos compuestos",
    "section": "4.4 Vectores",
    "text": "4.4 Vectores\nLos vectores son arrays de una dimensi√≥n.\nSe construyen escribiendo sus elementos separados por comas o puntos y comas entre corchetes.\njulia&gt; v = [1, 2, 3]\n3-element Vector{Int64}:\n 1\n 2\n 3\n\njulia&gt; length(v)\n3\n\njulia&gt; eltype(v)\nInt64\n\njulia&gt; ndims(v)\n1\n\njulia&gt; size(v)\n(3,)\n\njulia&gt; eachindex(v)\nBase.OneTo(3)\n\n4.4.1 Acceso a los elementos de un vector\nEl acceso a los elementos de un vector es mediante √≠ndices. Cada elemento del vector tiene asociado un √≠ndice entero que se corresponde con su posici√≥n desde 1 hasta el n√∫mero de elementos.\n\nv[i]: Devuelve el elemento del vector v con √≠ndice i.\n\n\n\n\n\n\n\nAdvertencia\n\n\n\nSi se proporciona un √≠ndice no v√°lido se produce un error.\n\n\nLas palabras reservadas begin y end se utilizan para referirse al primer y √∫ltimo √≠ndice de un vector.\n\n\n4.4.2 Ejemplo de acceso a los elementos de un vector\njulia&gt; v = [2, 4, 6]\n3-element Vector{Int64}:\n 2\n 4\n 6\n\njulia&gt; v[2]\n4\n\njulia&gt; v[end]\n6\n\njulia&gt; v[4]\nERROR: BoundsError: attempt to access 3-element Vector{Int64} at index [4]\nStacktrace:\n [1] getindex(A::Vector{Int64}, i1::Int64)\n   @ Base ./array.jl:861\n [2] top-level scope\n   @ REPL[4]:1\n\n\n4.4.3 Acceso a m√∫ltiples elementos de un vector\nEs posible extraer varios elementos de un vector a la vez indicando los √≠ndices mediante un rango o un vector de enteros.\n\nv[i:j]: Devuelve un vector con los elementos del vector v desde el √≠ndice i al j.\nv[u]: Devuelve un vector con los elementos del vector v correspondientes a los √≠ndices del vector u.\n\njulia&gt; v = [2, 4, 6, 8];\n\njulia&gt; v[2:3]\n2-element Vector{Int64}:\n 4\n 6\n\njulia&gt; v[[2,4,3]]\n3-element Vector{Int64}:\n 4\n 8\n 6\n\n\n4.4.4 Modificaci√≥n de los elementos de un vector\nTambi√©n es posible modificar un vector asignando nuevos elementos mediante los √≠ndices.\n\nv[i] = a: A√±ade el elemento a al vector v en el √≠ndice i.\n\njulia&gt; v = [2, 4, 6]\n3-element Vector{Int64}:\n 2\n 4\n 6\n\njulia&gt; v[2] = 0\n0\n\njulia&gt; v\n3-element Vector{Int64}:\n 2\n 0\n 6\n\n\n4.4.5 A√±adir elementos a un vector\nLas siguientes funciones permiten a√±adir elementos al final de un vector:\n\npush!(v, a): A√±ade el elemento a al final del vector v.\nappend!(v, u): A√±ade los elementos del vector u al final del vector v.\n\njulia&gt; v = [];\n\njulia&gt; push!(v, 1)\n1-element Vector{Any}:\n 1\n\njulia&gt; append!(v, [2, 3])\n3-element Vector{Any}:\n 1\n 2\n 3\n\njulia&gt; v\n3-element Vector{Any}:\n 1\n 2\n 3\n\n\n4.4.6 Recorrer un vector\nUna operaci√≥n habitual es recorrer los elementos de un vector para hacer cualquier operaci√≥n con ellos. Existen dos posibilidades: recorrer el vector por √≠ndice o por valor.\njulia&gt; v = [2, 4, 6];\n\njulia&gt; for i in v  # Recorrido por valor\n         println(i)\n       end\n2\n4\n6\n\njulia&gt; for i in eachindex(v)  # Recorrido por √≠ndice\n         println(v[i])\n       end\n2\n4\n6\n\n\n4.4.7 Operaciones con vectores num√©ricos\n\nminimum(v): Devuelve el menor elemento del vector v.\nmaximum(v): Devuelve el mayor elemento del vector v.\nargmin(v): Devuelve el √≠ndice del menor elemento del vector v.\nargmax(v): Devuelve el √≠ndice del mayor elemento del vector v.\nsum(v): Devuelve la suma de los elementos del vector v.\nprod(v): Devuelve el producto de los elementos del vector v.\nunique(v): Devuelve un vector con los elementos de v sin repetir.\n\njulia&gt; v = [4, 2, 3];\n\njulia&gt; maximum(v)\n4\n\njulia&gt; argmax(v)\n1\n\njulia&gt; sum(v)\n9\n\njulia&gt; prod(v)\n24\n\n\n4.4.8 Ordenaci√≥n de vectores\n\nsort(v, rev=true): Devuelve el vector que resulta de ordenar en orden ascendente los elementos del vector v. Si se pasa true al par√°metro rev el orden es descendente.\nsort!(v, rev=true): Ordena el vector v en orden ascendente. Si se pasa true al par√°metro rev el orden es descendente.\nreverse(v): Devuelve el vector con los elementos del vector v en orden inverso.\nreverse!(v): Modifica el vector v poniendo sus elementos en orden inverso.\n\n\n\n4.4.9 Ejemplo de ordenaci√≥n de vectores\njulia&gt; v = [4, 2, 3];\n\njulia&gt; sort(v)\n3-element Vector{Int64}:\n 2\n 3\n 4\n\njulia&gt; reverse(v)\n3-element Vector{Int64}:\n 3\n 2\n 4\n\njulia&gt; v\n3-element Vector{Int64}:\n 4\n 2\n 3\n\njulia&gt; reverse!(v)\n3-element Vector{Int64}:\n 3\n 2\n 4\n\njulia&gt; v\n3-element Vector{Int64}:\n 3\n 2\n 4\n\n\n4.4.10 Extensi√≥n de funciones a vectores\nSi una funci√≥n recibe un par√°metro del tipo de los elementos de un vector, se puede aplicar la funci√≥n a cada uno de los elementos del vector, extendiendo la llamada de la funci√≥n sobre los elementos del vector. Para ello basta con a√±adir un punto entre el nombre de la funci√≥n y el par√©ntesis de los argumentos.\n\nf.(v): Devuelve el vector que resulta de aplicar la funci√≥n f a cada uno de los elementos del vector v.\n\n\n\n\n\n\n\nAdvertencia\n\n\n\nEn la llamada a la funci√≥n hay que pasarle com argumentos tantos vectores como par√°metros tenga la funci√≥n. Si los vectores son de distinto tama√±o, se reciclan los de menor tama√±o.\n\n\n\n\n\n\n\n\nAdvertencia\n\n\n\nSi la funci√≥n no devuelve ning√∫n valor el resultado es un vector de valores nothing.\n\n\nLa extensi√≥n de funciones tambi√©n funciona con operadores, poniendo el punto delante del operador.\n\n\n4.4.11 Ejemplo de extensi√≥n de funciones a vectores\njulia&gt; v = [1, 4, 9];\n\njulia&gt; sqrt.(v)\n3-element Vector{Float64}:\n 1.0\n 2.0\n 3.0\n\njulia&gt; v .^ 2\n3-element Vector{Int64}:\n  1\n 16\n 81\n\njulia&gt; base = [2, ‚ÑØ, 10];\n\njulia&gt; log.(base, v)\n3-element Vector{Float64}:\n 0.0\n 1.3862943611198906\n 0.9542425094393249\n\n\n4.4.12 Filtrado de vectores\nOtra operaci√≥n bastante com√∫n son los filtros de vectores. Se puede filtrar un vector a partir de un vector de booleanos del mismo tama√±o.\n\nv[u]: Devuelve el vector con los elementos que tienen el mismo √≠ndice que los valores true del vector booleano u.\n\nEsto permite aplicar filtros a partir de condiciones que devuelvan un vector de booleanos.\n\n\n4.4.13 Ejemplo de filtrado de vectores\njulia&gt; v = [1, 2, 3, 4];\n\njulia&gt; v[[true, false, true, false]]\n2-element Vector{Int64}:\n 1\n 3\n\njulia&gt; v .% 2 .== 0  # Condici√≥n\n4-element BitVector:\n 0\n 1\n 0\n 1\n\njulia&gt; v[v .% 2 .== 0]  # Filtro de n√∫meros pares\n2-element Vector{Int64}:\n 2\n 4\n\n\n4.4.14 √Ålgebra lineal con vectores\n\nu + v: Devuelve el vector que resulta de la suma de los vetores u y v.\nu - v: Devuelve el vector que resulta de la resta de los vetores u y v.\na * v: De vuelve el vector que resulta de multiplicar el vector v por el escalar a.\nv': Devuelve el vector que resulta de trasponer el vector v. Si v es un vector fila, v' es un vector columna y viceversa.\n\nCon el paquete LinearAlgebra tambi√©n est√°n disponibles las siguientes funciones:\n\ndot(u, v): Devuelve el producto escalar de los vectores u y v.\nnorm(v): Devuelve la norma (m√≥dulo) del vector v.\n\n\n\n4.4.15 Ejemplo de √°lgebra lineal con vectores\nusing LinearAlgebra\n\njulia&gt; u = [1, 2, 3]; v = [1, 0, 2];\n\njulia&gt; u + v\n3-element Vector{Int64}:\n 2\n 2\n 5\n\njulia&gt; 2u\n3-element Vector{Int64}:\n 2\n 4\n 6\n\njulia&gt; dot(u, v)  # Producto escalar\n7\n\njulia&gt; u'v  # Producto escalar\n7\n\njulia&gt; norm(v)  # Norma o m√≥dulo\n2.23606797749979\n\njulia&gt; u / norm(u)  # Vector unitario\n3-element Vector{Float64}:\n 0.2672612419124244\n 0.5345224838248488\n 0.8017837257372732"
  },
  {
    "objectID": "tipos-datos-compuestos.html#matrices",
    "href": "tipos-datos-compuestos.html#matrices",
    "title": "4¬† Tipos de datos compuestos",
    "section": "4.5 Matrices",
    "text": "4.5 Matrices\nLas matrices son arrays de dos dimensiones (filas x columnas).\nSe construyen escribiendo sus elementos entre corchetes, separando los elementos por espacio y las filas por punto y coma ;.\njulia&gt; A = [1 2 3; 4 5 6]\n2√ó3 Matrix{Int64}:\n 1  2  3\n 4  5  6\n\njulia&gt; length(A)\n6\n\njulia&gt; eltype(A)\nInt64\n\njulia&gt; ndims(A)\n2\n\njulia&gt; size(A)\n(2, 3)\n\n4.5.1 Acceso a los elementos de una matriz\nEl acceso a los elementos de una matriz es mediante √≠ndices. Cada elemento de la matriz tiene asociado un par de √≠ndices enteros que se corresponde la fila y la columna que ocupa.\n\nA[i, j]: Devuelve el elemento de la matriz A con √≠ndice de fila i e √≠ndice de columna j.\n\n\n\n\n\n\n\nAdvertencia\n\n\n\nSi se proporciona alg√∫n √≠ndice no v√°lido se produce un error.\n\n\nTambi√©n se puede acceder a los elementos de una matriz mediante un √∫nico √≠ndice. En ese caso se obtiene el elemento con ese √≠ndice en el vector que resulta de concatenar los elementos de la matriz por columnas.\n\n\n4.5.2 Ejemplo de acceso a los elementos de una matriz\njulia&gt; A = reshape(1:6, 2, 3)\n2√ó3 reshape(::UnitRange{Int64}, 2, 3) with eltype Int64:\n 1  3  5\n 2  4  6\n\njulia&gt; A[2, 1]\n2\n\njulia&gt; A[4]\n4\n\n\n4.5.3 Acceso a m√∫ltiples elementos de una matriz\nEs posible extraer varios elementos de una matriz a la vez indicando los √≠ndices de las filas y las columnas mediante un rango o un vector de enteros.\n\nA[i:j, k:l]: Devuelve una matriz con los elementos desde el √≠ndice de fila i al j y el √≠ndice de columna k al l de la matriz A.\nA[u, w]: Devuelve una matriz con los elementos correspondientes a los √≠ndices de fila del vector u y los √≠ndices de columna del vector w de la matriz A.\n\n\n\n4.5.4 Ejemplo de acceso a m√∫ltiples elementos de una matriz\njulia&gt; A = reshape(1:9, 3, :)\n3√ó3 reshape(::UnitRange{Int64}, 3, 3) with eltype Int64:\n 1  4  7\n 2  5  8\n 3  6  9\n\njulia&gt; A[1:2, 2:3]\n2√ó2 Matrix{Int64}:\n 4  7\n 5  8\n\njulia&gt; A[[1, 3], [3, 1]]\n2√ó2 Matrix{Int64}:\n 7  1\n 9  3\n\njulia&gt; A[2, :]  # Segundo vector fila\n3-element Vector{Int64}:\n 2\n 5\n 8\n\n\n4.5.5 Modificaci√≥n de los elementos de una matriz\nTambi√©n es posible modificar una matriz asignando nuevos elementos mediante los √≠ndices de fila y columna.\n\nA[i, j] = a: A√±ade el elemento a a la matriz A con el √≠ndice de fila i y el √≠ndice de columna j.\n\njulia&gt; A = zeros(2, 3)\n2√ó3 Matrix{Float64}:\n 0.0  0.0  0.0\n 0.0  0.0  0.0\n\njulia&gt; A[2,3] = 1\n1\n\njulia&gt; A\n2√ó3 Matrix{Float64}:\n 0.0  0.0  0.0\n 0.0  0.0  1.0\n\n\n4.5.6 Concatenaci√≥n de matrices\nDos o m√°s matrices pueden concatenarse horizontal o verticalmente siempre que sus dimensiones sean compatibles.\n\n[A B]: Devuelve la matriz que resulta de concatenar horizontalmente las matrices A y B. Ambas matrices deben tener el mismo n√∫mero de filas.\n[A; B]: Devuelve la matriz que resulta de concatenar verticalmente las matrices A y B. Ambas matrices deben tener el mismo n√∫mero de columnas.\n\n\n\n4.5.7 Ejemplo de concatenaci√≥n de matrices\njulia&gt; A = zeros(2, 2)\n2√ó2 Matrix{Float64}:\n 0.0  0.0\n 0.0  0.0\n\njulia&gt; B = ones(2, 1)\n2√ó1 Matrix{Float64}:\n 1.0\n 1.0\n\njulia&gt; C = ones(1, 3)\n1√ó3 Matrix{Float64}:\n 1.0  1.0  1.0\n\njulia&gt; D = [A B]\n2√ó3 Matrix{Float64}:\n 0.0  0.0  1.0\n 0.0  0.0  1.0\n\njulia&gt; [D ; C]\n3√ó3 Matrix{Float64}:\n 0.0  0.0  1.0\n 0.0  0.0  1.0\n 1.0  1.0  1.0\n\n\n4.5.8 Concatenaci√≥n de vectores\nTambi√©n es posible concatenar varios vectores horizontalmente o verticalmente para formar una matriz.\n\nhcat(v...): Devuelve la matriz que resulta de concatenar horizontalmente los vectores del vector v.\nvcat(v...): Devuelve la matriz que resulta de concatenar verticalmente los vectores del vector v.\n\n\n\n4.5.9 Ejemplo de concatenaci√≥n de vectores\njulia&gt; v = [[1, 2, 3], [4, 5, 6]]\n2-element Vector{Vector{Int64}}:\n [1, 2, 3]\n [4, 5, 6]\n\njulia&gt; hcat(v...)\n3√ó2 Matrix{Int64}:\n 1  4\n 2  5\n 3  6\n\njulia&gt; v = [[1 2 3], [4 5 6]]\n2-element Vector{Matrix{Int64}}:\n [1 2 3]\n [4 5 6]\n\njulia&gt; vcat(v...)\n2√ó3 Matrix{Int64}:\n 1  2  3\n 4  5  6\n\n\n4.5.10 Recorrido de matrices\nUna operaci√≥n habitual es recorrer los elementos de una matriz para hacer una operaci√≥n con ellos. El recorrido se suele hacer con dos bucles iterativos anidados.\njulia&gt; A = [1 2 3; 4 5 6]\n2√ó3 Matrix{Int64}:\n 1  2  3\n 4  5  6\n\njulia&gt; for i = 1:size(A, 1), j = 1:size(A, 2)  # Recorrido por filas\n         println(A[i, j])\n       end\n1\n2\n3\n4\n5\n6\n\njulia&gt; for j = 1:size(A, 2), i = 1:size(A, 1)  # Recorrido por columnas\n         println(A[i, j])\n       end\n1\n4\n2\n5\n3\n6\n\n\n4.5.11 Operaciones con matrices num√©ricas\n\nminimum(A): Devuelve el menor elemento de la matriz A.\nmaximum(A): Devuelve el mayor elemento de la matriz A.\nargmin(A): Devuelve los √≠ndices de fila y columna del menor elemento de la matriz A.\nargmax(A): Devuelve los √≠ndices de fila y columna del mayor elemento de la matriz A.\nsum(A): Devuelve la suma de los elementos de la matriz A.\nprod(A): Devuelve el producto de los elementos de la matriz A.\n\njulia&gt; A = [1 2 3; 4 5 6]\n2√ó3 Matrix{Int64}:\n 1  2  3\n 4  5  6\n\njulia&gt; minimum(A)\n1\n\njulia&gt; argmax(A)\nCartesianIndex(2, 3)\n\njulia&gt; sum(A)\n21\n\njulia&gt; prod(A)\n720\n\n\n4.5.12 Extensi√≥n de funciones a matrices\nAl igual que para vectores, se puede aplicar una una funci√≥n a todos los elementos de una matriz. Para ello basta con a√±adir un punto entre el nombre de la funci√≥n y el par√©ntesis de los argumentos.\n\nf.(A): Devuelve la matriz que resulta de aplicar la funci√≥n f a cada uno de los elementos de la matriz A.\n\n\n\n\n\n\n\nAdvertencia\n\n\n\nEn la llamada a la funci√≥n hay que pasarle como argumentos tantos vectores como par√°metros tenga la funci√≥n. Si las matrices son de distinto tama√±o, se reciclan las de menor tama√±o.\n\n\nLa extensi√≥n de funciones tambi√©n funciona con operadores, poniendo el punto delante del operador.\n\n\n4.5.13 Ejemplo de extensi√≥n de funciones a matrices\njulia&gt; A = [1 2 3; 4 5 6]\n2√ó3 Matrix{Int64}:\n 1  2  3\n 4  5  6\n\njulia&gt; sqrt.(A)\n2√ó3 Matrix{Float64}:\n 1.0  1.41421  1.73205\n 2.0  2.23607  2.44949\n\njulia&gt; A .+ 1\n2√ó3 Matrix{Int64}:\n 2  3  4\n 5  6  7\n\n\n4.5.14 √Ålgebra lineal con matrices\n\nA + B: Devuelve la matriz que resulta de la suma de las matrices A y B. Ambas matrices deben tener las mismas dimensiones.\nA - B: Devuelve la matriz que resulta de la resta de las matrices A y B. Ambas matrices deben tener las mismas dimensiones.\na * A: Devuelve la matriz que resulta de multiplicar la matriz A por el escalar a.\nA * B: Devuelve la matriz producto de las matrices A y B. El n√∫mero de columnas de A debe coincidir con el n√∫mero de filas de B.\nA': Devuelve la matriz traspuesta de la matriz A.\ntranspose(A): Devuelve la matriz traspuesta de la matriz A.\n\n\n\n4.5.15 Ejemplo de √°lgebra lineal con matrices\njulia&gt; A = [1 2 3; 4 5 6]\n2√ó3 Matrix{Int64}:\n 1  2  3\n 4  5  6\n\njulia&gt; B = [1 1 1; 2 2 2]\n2√ó3 Matrix{Int64}:\n 1  1  1\n 2  2  2\n\njulia&gt; A + B\n2√ó3 Matrix{Int64}:\n 2  3  4\n 6  7  8\n\njulia&gt; C = A'\n3√ó2 adjoint(::Matrix{Int64}) with eltype Int64:\n 1  4\n 2  5\n 3  6\n\njulia&gt; A * C\n2√ó2 Matrix{Int64}:\n 14  32\n 32  77\n\njulia&gt; C * A\n3√ó3 Matrix{Int64}:\n 17  22  27\n 22  29  36\n 27  36  45\n\n\n4.5.16 √Ålgebra lineal con matrices\nEl paquete LinearAlgebra define las siguientes funciones:\n\nMatrix(I, n, n). Devuelve la matriz identidad de dimensi√≥n n.\ndiag(A): Devuelve un vector con los elementos de la diagonal principal de la matriz A.\nnorm(A): Devuelve la norma de Frobenius de la matriz A.\ntr(A): Devuelve la traza de la matriz cuadrada A.\ndet(A): Devuelve el determinante de la matriz cuadrada A.\ninv(A): Devuelve la matriz inversa de la matriz cuadrada A.\nA \\ B: Devuelve el vector x soluci√≥n del sistema de ecuaciones \\(Ax = B\\), donde A es una matriz cuadrada y B es un vector del mismo tama√±o que el n√∫mero de filas o columnas de A.\n\n\n\n4.5.17 Ejemplo de √°lgebra lineal con matrices\nusing LinearAlgebra\n\njulia&gt; Matrix(I, 3, 3)\n3√ó3 Matrix{Bool}:\n 1  0  0\n 0  1  0\n 0  0  1\n\njulia&gt; A = [1 2 3; 0 1 0; 1 0 1]\n3√ó3 Matrix{Int64}:\n 1  2  3\n 0  1  0\n 1  0  1\n\njulia&gt; diag(A)\n3-element Vector{Int64}:\n 1\n 1\n 1\n\njulia&gt; norm(A)\n4.123105625617661\n\njulia&gt; tr(A)\n3\n\njulia&gt; det(A)\n-2.0\n\njulia&gt; inv(A)\n3√ó3 Matrix{Float64}:\n -0.5   1.0   1.5\n  0.0   1.0   0.0\n  0.5  -1.0  -0.5\n\njulia&gt; B = [10, 2, 4]\n3-element Vector{Int64}:\n 10\n  2\n  4\n\njulia&gt; A \\ B  # Soluci√≥n del sistema Ax = B\n3-element Vector{Float64}:\n 3.0\n 2.0\n 1.0\n\n\n4.5.18 √Ålgebra lineal con matrices\nOtras funciones m√°s avanzadas del paquete LinearAlgebra son:\n\neigvals(A): Devuelve un vector con los autovalores de la matriz A.\neigvecs(A): Devuelve la matriz con los autovectores de la matriz A.\nfactorize(A): Devuelve las matrices resultantes de la factorizaci√≥n de la matriz A. La factorizaci√≥n depender√° de las propiedades de A (ver tipos de factorizaci√≥n)\n\n\n\n4.5.19 Ejemplos de √Ålgebra lineal con matrices\nusing LinearAlgebra\n\njulia&gt; A = [1 2; 3 1]\n2√ó2 Matrix{Int64}:\n 1  2\n 3  1\n\njulia&gt; eigvals(A)\n2-element Vector{Float64}:\n -1.4494897427831779\n  3.4494897427831783\n\njulia&gt; eigvecs(A)\n2√ó2 Matrix{Float64}:\n -0.632456  0.632456\n  0.774597  0.774597\n\njulia&gt; B = [1 2; 2 1]\n2√ó2 Matrix{Int64}:\n 1  2\n 2  1\n\njulia&gt; factorize(B)\nLU{Float64, Tridiagonal{Float64, Vector{Float64}}}\nL factor:\n2√ó2 Matrix{Float64}:\n 1.0  0.0\n 0.5  1.0\nU factor:\n2√ó2 Matrix{Float64}:\n 2.0  1.0\n 0.0  1.5\n\n\n4.5.20 Copia de tipos de datos compuestas\nEn Julia cuando se asigna una variable de un tipo de datos compuesto a otra variable, no se hace una copia de la estructura de datos referenciada por la primera variable, sino que se la nueva variable apunta a la misma direcci√≥n de memoria de la estructura de datos (copia por referencia). El resultado son dos variables que apuntan a la misma estructura de datos y cualquier cambio en una de ellas se ver√° reflejado en la otra.\nPara hacer copias por valor de un tipo de datos compuesto debe usarse expl√≠citamente la siguiente funci√≥n:\n\nb = copy(a): Crea una copia de la estructura de datos referencia por a y asigna su referencia a b.\n\n\n\n4.5.21 Ejemplo de copia de tipos de datos compuestos\njulia&gt; v = [1, 2, 3];\n\njulia&gt; u = copy(v);  # Copia por valor\n\njulia&gt; u[2] = 0;\n\njulia&gt; u\n3-element Vector{Int64}:\n 1\n 0\n 3\n\njulia&gt; v\n3-element Vector{Int64}:\n 1\n 2\n 3\n\njulia&gt; u = v;  # Copia por referencia\n\njulia&gt; u[2]=0;\n\njulia&gt; v\n3-element Vector{Int64}:\n 1\n 0\n 3"
  },
  {
    "objectID": "tipos-datos-compuestos.html#tuplas",
    "href": "tipos-datos-compuestos.html#tuplas",
    "title": "4¬† Tipos de datos compuestos",
    "section": "4.6 Tuplas",
    "text": "4.6 Tuplas\nUna tupla es una colecci√≥n ordenada de tama√±o fijo que puede contener elementos de distintos tipos.\nGeneralmente se usan para pasar par√°metros o devolver valores de funciones.\nSe crean escribiendo sus elementos separados por comas entre par√©ntesis.\n\n\n\n\n\n\nAdvertencia\n\n\n\nLas tuplas son inmutables, es decir, una vez creadas no pueden cambiarse sus elementos.\n\n\njulia&gt; ()  # Tupla vac√≠a\n()\n\njulia&gt; (1, \"enero\", 2020) \n(1, \"enero\", 2020)\n\njulia&gt; t = (1, \"enero\", 2020)\n(1, \"enero\", 2020)\n\njulia&gt; typeof(t)\nTuple{Int64, String, Int64}\n\n4.6.1 Tuplas con nombres\nEs posible asignar un nombre a cada uno de los elementos de la tupla. Para ello cada elemento de la tupla con nombre debe escribirse con la sintaxis nombre = valor.\njulia&gt; t = (d√≠a = 1, mes = \"enero\", a√±o =  2020)\n(d√≠a = 1, mes = \"enero\", a√±o = 2020)\n\njulia&gt; typeof(t)\nNamedTuple{(:d√≠a, :mes, :a√±o), Tuple{Int64, String, Int64}}\n\n\n\n\n\n\nAdvertencia\n\n\n\nNo puede haber dos elementos con el mismo nombre en una tupla.\n\n\nLa ventaja de usar tuplas con nombres es que podemos acceder a sus elementos por nombre, adem√°s de por √≠ndice.\n\n\n4.6.2 Acceso a los elementos de una tupla\nComo las tuplas tienen orden, podemos acceder a sus elementos mediante √≠ndices, al igual que con los arrays de una dimensi√≥n.\n\nt[i]: Devuelve el elemento con √≠ncide i de la tupla t.\n\nSi la tupla tiene nombres tambi√©n es posible acceder a sus elementos mediante los nombres.\n\nt.x: Devuelve el elemento con nombre x de la tupla t.\n\njulia&gt; t = (d√≠a = 1, mes = \"enero\", a√±o =  2020)\n(d√≠a = 1, mes = \"enero\", a√±o = 2020)\n\njulia&gt; t[2]\n\"enero\"\n\njulia&gt; t.a√±o\n2020\n\njulia&gt; \n\n\n4.6.3 Asignaci√≥n m√∫ltiple de tuplas\nEs posible asignar los elementos de una tupla a distintas variables en una sola asignaci√≥n.\nx, y, ... = t: Asigna a las variables x, y, etc los elementos de la tupla t en orden. Si el n√∫mero de variables es menor que el tama√±o de la tupla, los √∫ltimos elementos quedan sin asignar.\nx, y... = t: Asigna el primer elemento de la tupla t a la variable x y la tupla con los elementos restantes a la variable y.\n\n\n4.6.4 Ejemplo de asignaci√≥n m√∫ltipe de tuplas\njulia&gt; t = (1, \"enero\", 2020)\n(1, \"enero\", 2020)\n\njulia&gt; d, m, a = t\n(1, \"enero\", 2020)\n\njulia&gt; d\n1\n\njulia&gt; m\n\"enero\"\n\njulia&gt; a\n2020\n\njulia&gt; d, ma... = t \n(1, \"enero\", 2020)\n\njulia&gt; d\n1\n\njulia&gt; ma\n(\"enero\", 2020)"
  },
  {
    "objectID": "tipos-datos-compuestos.html#diccionarios",
    "href": "tipos-datos-compuestos.html#diccionarios",
    "title": "4¬† Tipos de datos compuestos",
    "section": "4.7 Diccionarios",
    "text": "4.7 Diccionarios\nUn diccionario es una colecci√≥n asociativa sin orden cuyos elementos son pares formados por una clave y un valor asociado a la clave.\nSe parecen a las tuplas con nombre, pero, a diferencia de estas, son mutables, es decir, su contenido se puede alterar.\nSe construyen con la siguiente constructor:\n\nDict(k1 =&gt; v1, ...): Crea un diccionario con los pares indicados en formato clave =&gt; valor.\n\n\n\n\n\n\n\nAdvertencia\n\n\n\nEn un diccionario no pueden existir dos pares con la misma clave, de modo que si se repite una clave se sobrescribe el par anterior.\n\n\n\n4.7.1 Ejemplo de diccionarios\njulia&gt; Dict()  # Diccionario vac√≠o\nDict{Any, Any}()\n\njulia&gt; d = Dict(\"ES\" =&gt; \"Euro\", \"US\" =&gt; \"Dollar\", \"CN\" =&gt; \"Yuan\")\nDict{String, String} with 3 entries:\n  \"CN\" =&gt; \"Yuan\"\n  \"ES\" =&gt; \"Euro\"\n  \"US\" =&gt; \"Dollar\"\n\njulia&gt; typeof(d)\nDict{String, String}\n\n\n4.7.2 Comprensi√≥n de diccionarios\nAl igual que para arrays se puede usar la t√©cnica de compresi√≥n para generar diccionarios a partir de uno o varios iteradores.\n\nDict(kexp =&gt; vexp for i = ite): Devuelve el diccionario cuyos pares est√°n formados por la claves y valores resultan de evaluar las expresiones kexp y vexp respectivamente, para cada valor i del iterador ite.\nDict(kexp =&gt; vexp for i = ite if cond): Devuelve el diccionario cuyos pares est√°n formados por la claves y valores resultan de evaluar las expresiones kexp y vexp respectivamente, para cada valor i del iterador ite que cumpla condici√≥n cond.\n\nSe pueden utilizar m√°s de un iterador despu√©s de la palabra reservada for.\n\n\n4.7.3 Ejemplo de comprensi√≥n de diccionarios\njulia&gt; Dict(i =&gt; i^2 for i = 1:4)\nDict{Int64, Int64} with 4 entries:\n  4 =&gt; 16\n  2 =&gt; 4\n  3 =&gt; 9\n  1 =&gt; 1\n\njulia&gt; Dict(i =&gt; i^2 for i = 1:4 if i % 2 == 0)\nDict{Int64, Int64} with 2 entries:\n  4 =&gt; 16\n  2 =&gt; 4\n\njulia&gt; Dict((i, j) =&gt; i + j for i = 1:2, j = 3:4)\nDict{Tuple{Int64, Int64}, Int64} with 4 entries:\n  (2, 4) =&gt; 6\n  (1, 3) =&gt; 4\n  (1, 4) =&gt; 5\n  (2, 3) =&gt; 5\n\n\n4.7.4 Acceso a los elementos de un diccionario\nPara acceder a los valores de un diccionario se utilizan sus claves asociadas entre corchetes.\n\nd[k]: Devuelve el valor asociado a la clave k en el diccionario d.\n\n\n\n\n\n\n\nAdvertencia\n\n\n\nSi la clave no existe en el diccionario se produce un error.\n\n\nPara evitar errores es conveniente usar alguna de las siguientes funciones:\n\nhaskey(d, k): Devuelve true la clave k est√° en diccionario d y false en caso contrario.\nget(d, k, v): Devuelve el valor asociado a la clave k en el diccionario d o el valor v si la clave k no existe.\nget!(d, k, v): Devuelve el valor asociado a la clave k en el diccionario d. Si la clave k no existe en el diccionario d a√±ade el par con la clave k y el valor v y devuelve el valor v.\n\n\n\n4.7.5 Ejemplo de acceso a los elementos de un diccionario\njulia&gt; d = Dict(\"ES\" =&gt; \"Euro\", \"US\" =&gt; \"Dollar\", \"CN\" =&gt; \"Yuan\")\nDict{String, String} with 3 entries:\n  \"CN\" =&gt; \"Yuan\"\n  \"ES\" =&gt; \"Euro\"\n  \"US\" =&gt; \"Dollar\"\n\njulia&gt; d[\"ES\"]\n\"Euro\"\n\njulia&gt; d[\"JP\"]\nERROR: KeyError: key \"JP\" not found\nStacktrace:\n [1] getindex(h::Dict{String, String}, key::String)\n   @ Base ./dict.jl:481\n [2] top-level scope\n   @ REPL[22]:1\n\njulia&gt; get(d, \"JP\", \"Dollar\")\n\"Dollar\"\n\njulia&gt; get!(d, \"JP\", \"Yen\")\n\"Yen\"\n\njulia&gt; d\nDict{String, String} with 4 entries:\n  \"CN\" =&gt; \"Yuan\"\n  \"ES\" =&gt; \"Euro\"\n  \"JP\" =&gt; \"Yen\"\n  \"US\" =&gt; \"Dollar\"\n\n\n4.7.6 Recorrido de las claves y valores de un diccionario\nLas siguientes funciones permiten obtener todas las claves, valores y pares de un diccionario.\n\nkeys(d): Devuelve un iterador con las claves del diccionario d.\nvalues(d): Devuelve un iterador con los valores del diccionario d.\n\nEstos iteradores permiten recorrer f√°cilmente los pares de un diccionario.\n\n\n4.7.7 Ejemplo de recorrido de las claves y valores de un diccionario\njulia&gt; d = Dict(\"ES\" =&gt; \"Euro\", \"US\" =&gt; \"Dollar\", \"CN\" =&gt; \"Yuan\")\nDict{String, String} with 3 entries:\n  \"CN\" =&gt; \"Yuan\"\n  \"ES\" =&gt; \"Euro\"\n  \"US\" =&gt; \"Dollar\"\n\njulia&gt; keys(d)\nKeySet for a Dict{String, String} with 3 entries. Keys:\n  \"CN\"\n  \"ES\"\n  \"US\"\n\njulia&gt; values(d)\nValueIterator for a Dict{String, String} with 3 entries. Values:\n  \"Yuan\"\n  \"Euro\"\n  \"Dollar\"\n\njulia&gt; for k = keys(d)\n         println(\"$k = $(d[k])\")\n       end\nCN = Yuan\nES = Euro\nUS = Dollar\n\njulia&gt; for (k, v) = d\n       println(\"$k = $v\")\n       end\nCN = Yuan\nES = Euro\nUS = Dollar\n\n\n4.7.8 A√±adir elementos a un diccionario\nSe pueden a√±adir pares nuevos a un diccionario de la siguiente manera:\n\nd[k] = v: A√±ade el par con clave k y valor v al diccionario d. Si la clave k ya exist√≠a en el diccionario d, cambia su valor asociado por v.\npush!(d, k =&gt; v): A√±ade el par con clave k y valor asociado v al diccionario d.\n\njulia&gt; d = Dict(\"ES\" =&gt; \"Euro\", \"US\" =&gt; \"Dollar\")\nDict{String, String} with 2 entries:\n  \"ES\" =&gt; \"Euro\"\n  \"US\" =&gt; \"Dollar\"\n\njulia&gt; d[\"CN\"] = \"Yuan\"\n\"Yuan\"\n\njulia&gt; push!(d, \"JP\" =&gt; \"Yen\")\nDict{String, String} with 4 entries:\n  \"CN\" =&gt; \"Yuan\"\n  \"ES\" =&gt; \"Euro\"\n  \"JP\" =&gt; \"Yen\"\n  \"US\" =&gt; \"Dollar\"\n\n\n4.7.9 Eliminar elementos de un diccionario\nPara eliminar un par de un diccionario se utiliza la siguiente funci√≥n:\n\ndelete!(d, k): Elimina el par cuya clave es k del diccionario d.\n\njulia&gt; d = Dict(\"ES\" =&gt; \"Euro\", \"US\" =&gt; \"Dollar\", \"CN\" =&gt; \"Yuan\")\nDict{String, String} with 3 entries:\n  \"CN\" =&gt; \"Yuan\"\n  \"ES\" =&gt; \"Euro\"\n  \"US\" =&gt; \"Dollar\"\n\njulia&gt; delete!(d, \"US\")\nDict{String, String} with 2 entries:\n  \"CN\" =&gt; \"Yuan\"\n  \"ES\" =&gt; \"Euro\""
  },
  {
    "objectID": "tipos-datos-compuestos.html#conjuntos",
    "href": "tipos-datos-compuestos.html#conjuntos",
    "title": "4¬† Tipos de datos compuestos",
    "section": "4.8 Conjuntos",
    "text": "4.8 Conjuntos\nUn conjunto es una colecci√≥n de elementos del mismo tipo sin orden y sin repeticiones.\nSe construyen con la siguiente constructor:\n\nSet(a): Crea un conjunto con los elementos del array a.\n\nAl igual que para arrays el tipo se infiere autom√°ticamente a partir de los tipos de sus elementos. Si los elementos son de distintos tipos se convierten al tipo m√°s espec√≠fico de la jerarqu√≠a de tipos del que los tipos de los elementos son subtipos.\n\n\n\n\n\n\nAdvertencia\n\n\n\nUn conjunto no puede tener elementos repetidos, por lo que si el array contiene elementos repetidos solo se incluyen una vez.\n\n\n\n4.8.1 Ejemplo de construcci√≥n de conjuntos\njulia&gt; Set()\nSet{Any}()\n\njulia&gt; c = Set([1, \"2\", 3])\nSet{Any} with 3 elements:\n  \"2\"\n  3\n  1\n\njulia&gt; typeof(c)\nSet{Any}\n\n\n4.8.2 A√±adir elementos a un conjunto\nPara a√±adir elementos a un conjunto se utiliza la siguiente funci√≥n:\n\npush!(c, e): A√±ade el elemento e al conjunto c.\n\n\n\n\n\n\n\nAdvertencia\n\n\n\nSi el elemento que se quiere a√±adir es de distinto tipo que los elemento del conjunto y no puede convertirse a este tipo, se produce un error.\n\n\n\n\n4.8.3 Ejemplo de a√±adir elementos a un conjunto\njulia&gt; c = Set(1:3)\nSet{Int64} with 3 elements:\n  2\n  3\n  1\n\njulia&gt; push!(c, 4)\nSet{Int64} with 4 elements:\n  4\n  2\n  3\n  1\n\njulia&gt; push!(c, \"cinco\")\nERROR: MethodError: Cannot `convert` an object of type String to an object of type Int64\nClosest candidates are:\n  convert(::Type{T}, ::T) where T&lt;:Number at /usr/share/julia/base/number.jl:6\n  convert(::Type{T}, ::Number) where T&lt;:Number at /usr/share/julia/base/number.jl:7\n  convert(::Type{T}, ::Base.TwicePrecision) where T&lt;:Number at /usr/share/julia/base/twiceprecision.jl:262\n  ...\n\n\n4.8.4 Eliminar elementos de un conjunto\nPara eliminar elementos de un conjunto se utiliza la siguiente funci√≥n:\n\ndelete!(c, e): Elimina el elemento e del conjunto c.\n\njulia&gt; c = Set(1:3)\nSet{Int64} with 3 elements:\n  2\n  3\n  1\n\njulia&gt; delete!(c, 2)\nSet{Int64} with 2 elements:\n  3\n  1\n\n\n4.8.5 Recorrido de los elementos de un conjunto\nUn conjunto puede utilizarse tambi√©n como un iterador para recorrer sus elementos.\njulia&gt; c = Set(1:3)\nSet{Int64} with 3 elements:\n  2\n  3\n  1\n\njulia&gt; for i = c\n         println(i)\n       end\n2\n3\n1\n\n\n4.8.6 Pertenencia e inclusi√≥n de conjuntos\n\nin(e, c), e ‚àà c : Devuelve true si el elemento e pertenece al conjunto c y false en caso contrario.\ne ‚àâ c: Devuelve true si el elemento e no pertenece al conjunto c y false en caso contrario.\nissubset(a, b), a ‚äÜ b: Devuelve true si todos los elementos de a pertenecen a b y false en caso contrario.\na ‚äà b: Devuelve true si hay alg√∫n elemento de a que no pertenece a b.\na ‚ää b: Devuelve true si el conjunto a est√° contenido estrictamente en el conjunto b, es decir, todos los elementos de a pertenecen a b pero a y b son distintos.\nisdisjoint(a, b): Devuelve true si los conjuntos a y b no tienen elementos en com√∫n y false en caso contrario.\n\n\n\n4.8.7 Ejemplos de pertenencia e inclusi√≥n de conjuntos\njulia&gt; a = Set(1:3);\n\njulia&gt; in(2, a)\ntrue\n\njulia&gt; 3 ‚àâ a\nfalse\n\njulia&gt; b = Set([3, 2, 1]);\n\njulia&gt; a ‚ää b\nfalse\n\njulia&gt; a ‚äÜ b\ntrue\n\njulia&gt; isdisjoint(a, b)\nfalse\n\n\n4.8.8 √Ålgebra de conjuntos\n\nunion(a, b), a ‚à™ b: Devuelve el conjunto uni√≥n de los conjuntos a y b.\nintersect(a, b), a ‚à© b: Devuelve el conjunto intersecci√≥n de los conjuntos a y b.\nsetdiff(a, b): Devuelve el conjunto diferencia del conjunto a y b.\nsymdiff(a, b): Devuelve el conjunto diferencia sim√©trica de los conjuntos a y b.\n\nExisten versiones de estas funciones acabadas en ! que sobreescriben el conjunto dado como primer argumento con el resultado de la operaci√≥n.\n\n\n4.8.9 Ejemplo de √°lgebra de conjuntos\njulia&gt; a = Set(1:3)\nSet{Int64} with 3 elements:\n  2\n  3\n  1\n\njulia&gt; b = Set(2:2:6)\nSet{Int64} with 3 elements:\n  4\n  6\n  2\n\njulia&gt; union(a, b)\nSet{Int64} with 5 elements:\n  4\n  6\n  2\n  3\n  1\n\njulia&gt; intersect(a, b)\nSet{Int64} with 1 element:\n  2\n\njulia&gt; setdiff(a, b)\nSet{Int64} with 2 elements:\n  3\n  1\n\njulia&gt; symdiff(a, b) == setdiff(a ‚à™ b, a ‚à© b)\ntrue"
  },
  {
    "objectID": "funciones.html#creaci√≥n-de-funciones",
    "href": "funciones.html#creaci√≥n-de-funciones",
    "title": "5¬† Funciones",
    "section": "5.1 Creaci√≥n de funciones",
    "text": "5.1 Creaci√≥n de funciones\nUna funci√≥n asocia un nombre a un bloque de c√≥digo de manera que cada vez que se invoca a la funci√≥n se ejecuta el bloque de c√≥digo asociado.\nPara crear una funci√≥n se utiliza la siguiente sintaxis\n\nfunction nombre(par√°metros)\n¬†¬†¬†bloque de c√≥digo\nend\n\n\n\n\n\n\n\nNota\n\n\n\nLa indentaci√≥n del bloque de c√≥digo no es necesaria pero es una buena pr√°ctica.\n\n\nPara invocar una funci√≥n basta con escribir su nombre y pasarle entre par√©ntesis los valores de los par√°metros (argumentos) separados por comas.\n\n5.1.1 Ejemplo de creaci√≥n de funciones\njulia&gt; function saludo()  # Funci√≥n sin par√°metros\n         println(\"¬°Bienvenido!\")\n       end\nsaludo (generic function with 1 method)\n\njulia&gt; saludo()\n¬°Bienvenido!\n\njulia&gt; typeof(saludo)\ntypeof(saludo) (singleton type of function saludo, subtype of Function)"
  },
  {
    "objectID": "funciones.html#par√°metros-y-argumentos-de-una-funci√≥n",
    "href": "funciones.html#par√°metros-y-argumentos-de-una-funci√≥n",
    "title": "5¬† Funciones",
    "section": "5.2 Par√°metros y argumentos de una funci√≥n",
    "text": "5.2 Par√°metros y argumentos de una funci√≥n\nUna funci√≥n puede recibir valores cuando se invoca a trav√©s de unas variables conocidas como par√°metros que se definen entre par√©ntesis y separados por comas en la declaraci√≥n de la funci√≥n. En el cuerpo de la funci√≥n se pueden usar estos par√°metros como si fuesen variables.\nLos valores que se pasan a la funci√≥n en una llamada o invocaci√≥n concreta de ella se conocen como argumentos y se asocian a los par√°metros de la declaraci√≥n de la funci√≥n.\njulia&gt; function calificacion(nota)  # Funci√≥n con un par√°metro\n         if nota &lt; 5\n           println(\"Suspenso\")\n         else\n           println(\"Aprobado\")\n         end\n       end\ncalificacion (generic function with 1 method)\n\njulia&gt; calificacion(7)\nAprobado\n\n5.2.1 Paso de argumentos a una funci√≥n\nLos argumentos se pueden pasar de dos formas:\n\nArgumentos posicionales: Se asocian a los par√°metros de la funci√≥n en el mismo orden que aparecen en la definici√≥n de la funci√≥n.\nArgumentos nominales: Se indica expl√≠citamente el nombre del par√°metro al que se asocia un argumento de la forma parametro = argumento.\n\nCuando una funci√≥n tiente par√°metros posicionales y como nominales, los posicionales deben indicarse primero y los nominales despu√©s, separando ambos tipos de par√°metros por punto y coma ;.\n\n\n5.2.2 Ejemplo de paso de argumentos a una funci√≥n\njulia&gt; function saludo(nombre, apellidos; ciudad)\n       println(\"¬°Hola $nombre $apellidos, bienvenido a $(ciudad)!\")\n       end\nsaludo (generic function with 1 method)\n\njulia&gt; saludo(\"Alfredo\", \"S√°nchez\", ciudad = \"Madrid\")\n¬°Hola Alfredo S√°nchez, bienvenido a Madrid!\n\njulia&gt; saludo(\"Alfredo\", ciudad = \"Madrid\",  \"S√°nchez\")\n¬°Hola Alfredo S√°nchez, bienvenido a Madrid!\n\n\n5.2.3 Argumentos por defecto\nEn la definici√≥n de una funci√≥n se puede asignar a cada par√°metro un argumento por defecto, de manera que si se invoca la funci√≥n sin proporcionar ning√∫n argumento para ese par√°metro, se utiliza el argumento por defecto.\nEl valor por defecto de un par√°metro se indica con la siguiente sintaxis par√°metro = valor.\njulia&gt; function saludo(nombre, apellidos, ciudad = \"Madrid\")\n         println(\"¬°Hola $nombre $apellidos, bienvenido a $(ciudad)!\")\n       end\nsaludo (generic function with 2 methods)\n\njulia&gt; saludo(\"Alfredo\", \"S√°nchez\")\n¬°Hola Alfredo S√°nchez, bienvenido a Madrid!\n\njulia&gt; saludo(\"Pepito\", \"Grillo\", \"Barcelona\")\n¬°Hola Pepito Grillo, bienvenido a Barcelona!\n\n\n5.2.4 Funciones con un n√∫mero variable de argumentos\nJulia permite definir funciones que pueden llamarse con un n√∫mero variable de argumentos. Para que una funci√≥n pueda recibir un n√∫mero variable de argumentos hay que poner tres puntos suspensivos ... al final de √∫ltimo par√°metro posicional.\nCuando se llame a la funci√≥n los argumentos se ir√°n asociando a los par√°metros posicionales en orden y el √∫ltimo par√°metro se asociar√° a una tupla con el resto de argumentos en la llamada.\njulia&gt; function media(x...)\n       println(\"Media de \", x)\n       sum(x) / length(x)\n       end\nmedia (generic function with 1 method)\n\njulia&gt; media(1, 2, 3, 4)\nMedia de (1, 2, 3, 4)\n2.5\n\n\n5.2.5 Par√°metros con tipo\nAunque Julia es un lenguaje de tipado din√°mico tambi√©n permite fijar el tipo de los par√°metros de una una funci√≥n. Esto permite definir diferentes variantes (m√©todos) de una misma funci√≥n dependiendo del tipo de los argumentos, as√≠ como detectar errores cuando se llama a la funci√≥n con argumentos de distinto tipo.\nPara indicar el tipo de los par√°metros de una funci√≥n se utiliza la sintaxis parametro::tipo.\n\n\n\n\n\n\nAdvertencia\n\n\n\nConviene no restringir demasiado el tipo de los par√°metros de una funci√≥n. Se debe elegir el tipo m√°s general en la jerarqu√≠a de tipos para el que tiene sentido la funci√≥n.\n\n\n\n\n5.2.6 Ejemplo de par√°metros con tipo\njulia&gt; function sumar(x::Number, y::Number)\n       x + y\n       end\nsumar (generic function with 1 method)\n\njulia&gt; function sumar(x::String, y::String)\n       x * y\n       end\nsumar (generic function with 2 methods)\n\njulia&gt; sumar(1, 2)\n3\n\njulia&gt; sumar(1.5, 2.5)\n4.0\n\njulia&gt; sumar(\"Hola\", \"Julia\")\n\"HolaJulia\"\n\n\n5.2.7 Paso de argumentos por asignaci√≥n\nEn Julia los argumentos se pasan a una funci√≥n por asignaci√≥n, es decir, se asignan a los par√°metros de la funci√≥n como si fuesen variables locales. De este modo, cuando los argumentos son objetos mutables (arrays, diccionarios, etc.) se pasa al par√°metro una referencia al objeto, de manera que cualquier cambio que se haga en la funci√≥n mediante el par√°metro asociado afectar√° al objeto original y ser√°n visibles fuera de ella.\njulia&gt; function matricular(curso, asignatura)\n       push!(curso, asignatura)\n       end\nmatricular (generic function with 1 method)\n\njulia&gt; primer_curso = [];\n\njulia&gt; matricular(primer_curso, \"√Ålgebra Lineal\");\n\njulia&gt; matricular(primer_curso, \"Programaci√≥n\");\n\njulia&gt; primer_curso\n2-element Vector{Any}:\n \"√Ålgebra Lineal\"\n \"Programaci√≥n\"\n\n\n5.2.8 √Åmbito de los par√°metros de una funci√≥n\nLos par√°metros y las variables declaradas dentro de una funci√≥n son de √°mbito local, mientras que las variable definidas fuera de funciones son de √°mbito √°mbito global.\nTanto los par√°metros como las variables del √°mbito local de una funci√≥n s√≥lo est√°n accesibles durante la ejecuci√≥n de la funci√≥n. Es decir, cuando termina la ejecuci√≥n de la funci√≥n estas variables desaparecen y no son accesibles desde fuera de la funci√≥n.\nSi en el √°mbito local de una funci√≥n existe una variable que tambi√©n existe en el √°mbito global, durante la ejecuci√≥n de la funci√≥n la variable global queda eclipsada por la variable local y no es accesible hasta que finaliza la ejecuci√≥n de la funci√≥n.\n\n\n5.2.9 Ejemplo del √°mbito de los par√°metros de una funci√≥n\njulia&gt; lenguaje = \"Python\";\n\njulia&gt; function saludo(nombre)\n       lenguaje = \"Julia\"\n       println(\"¬°Hola $(nombre), bienvenido a $(lenguaje)!\")\n       end\nsaludo (generic function with 3 methods)\n\njulia&gt; saludo(\"Alf\")\n¬°Hola Alf, bienvenido a Julia!\n\njulia&gt; lenguaje\n\"Python\"\n\njulia&gt; nombre\nERROR: UndefVarError: nombre not defined"
  },
  {
    "objectID": "funciones.html#retorno-de-una-funci√≥n",
    "href": "funciones.html#retorno-de-una-funci√≥n",
    "title": "5¬† Funciones",
    "section": "5.3 Retorno de una funci√≥n",
    "text": "5.3 Retorno de una funci√≥n\nUna funci√≥n devuelve siempre el valor de la √∫ltima expresi√≥n evaluada en su cuerpo. Sin embargo, puede devolverse cualquier otro valor indic√°ndolo detr√°s de la palabra reservada return. Cuando el flujo de ejecuci√≥n de la funci√≥n alcanza esta palabra, la ejecuci√≥n de la funci√≥n termina y se devuelve el valor que la acompa√±a.\nSi una funci√≥n no devuelve ning√∫n valor se puede escribir la palabra return sin nada m√°s.\nCuando se desea devolver m√°s de un valor se puede pueden indicar separados por comas y la funci√≥n devolver√° la tupla formada por esos valores.\n\n5.3.1 Ejemplo de retorno de una funci√≥n\njulia&gt; function area_triangulo(base, altura)\n         return base * altura / 2  # Devuelve un valor\n       end\narea_triangulo (generic function with 1 method)\n\njulia&gt; area_triangulo(3, 4)\n6.0\n\njulia&gt; function area_perimetro_circulo(r)\n         return œÄ * r ^ 2, 2œÄ * r  # Devuelve dos valores \n       end\narea_perimetro_circulo (generic function with 1 method)\n\njulia&gt; area_perimetro_circulo(1)\n(3.141592653589793, 6.283185307179586)"
  },
  {
    "objectID": "funciones.html#funciones-compactas",
    "href": "funciones.html#funciones-compactas",
    "title": "5¬† Funciones",
    "section": "5.4 Funciones compactas",
    "text": "5.4 Funciones compactas\nCuando el cuerpo de una funci√≥n es una √∫nica expresi√≥n se puede definir la funci√≥n de forma mucho m√°s compacta de la siguiente manera:\n\nnombre(parametros) = expresi√≥n\n\nEl valor que devuelve la funci√≥n es el resultado de evaluar la expresi√≥n.\nEsta forma de definir funciones es muy habitual para funciones matem√°ticas.\njulia&gt; area_triangulo(b, a) = b * a / 2\narea_triangulo (generic function with 1 method)\n\njulia&gt; area_triangulo(3, 4)\n6.0\n\njulia&gt; valor_absoluto(x) = x &lt; 0 ? -x : x\nvalor_absoluto (generic function with 1 method)\n\njulia&gt; valor_absoluto(-1)\n1"
  },
  {
    "objectID": "funciones.html#funciones-como-objetos",
    "href": "funciones.html#funciones-como-objetos",
    "title": "5¬† Funciones",
    "section": "5.5 Funciones como objetos",
    "text": "5.5 Funciones como objetos\nEn Julia las funciones son objetos como el resto de tipos de datos, de manera que es posible asignar una funci√≥n a una variable y luego utilizar la variable para hacer la llamada a la funci√≥n, pasar una funci√≥n como argumento de otra funci√≥n, o que una funci√≥n devuelva otra funci√≥n.\njulia&gt; suma(x, y) = x + y\nsuma (generic function with 1 method)\n\njulia&gt; adicion = suma\nsuma (generic function with 1 method)\n\njulia&gt; adicion(1, 2)\n3\n\njulia&gt; calculadora(operador, x, y) = operador(x, y) \ncalculadora (generic function with 1 method)\n\njulia&gt; calculadora(suma, 1, 2)\n3"
  },
  {
    "objectID": "funciones.html#funciones-an√≥nimas",
    "href": "funciones.html#funciones-an√≥nimas",
    "title": "5¬† Funciones",
    "section": "5.6 Funciones an√≥nimas",
    "text": "5.6 Funciones an√≥nimas\nJulia permite tambi√©n definir funciones sin nombre. Para ello se utiliza la siguiente sintaxis.\n\n(parametros) -&gt; expresi√≥n\n\nEl principal uso de las funciones an√≥nimas es para pasarlas como argumentos de otras funciones.\nulia&gt; calculadora(operador, x, y) = operador(x, y) \ncalculadora (generic function with 1 method)\n\njulia&gt; calculadora((x, y) -&gt; x + y, 1, 2)\n3\n\njulia&gt; calculadora((x, y) -&gt; x - y, 1, 2)\n-1"
  },
  {
    "objectID": "funciones.html#funciones-asociadas-a-operadores",
    "href": "funciones.html#funciones-asociadas-a-operadores",
    "title": "5¬† Funciones",
    "section": "5.7 Funciones asociadas a operadores",
    "text": "5.7 Funciones asociadas a operadores\nEn Julia los operadores tienen asociadas funciones que son llamadas por el int√©rprete cuando se eval√∫a una expresi√≥n con operadores.\njulia&gt; +(1, 2, 3)  # Equivalente a 1 + 2 + 3\n6\n\njulia&gt; ‚àë = +\n+ (generic function with 208 methods)\n\njulia&gt; ‚àë(1, 2, 3)\n6"
  },
  {
    "objectID": "funciones.html#funciones-recursivas",
    "href": "funciones.html#funciones-recursivas",
    "title": "5¬† Funciones",
    "section": "5.8 Funciones recursivas",
    "text": "5.8 Funciones recursivas\nUna funci√≥n recursiva es una funci√≥n que en su cuerpo contiene alguna llama a si misma.\nLa recursi√≥n es una pr√°ctica com√∫n en la mayor√≠a de los lenguajes de programaci√≥n ya que permite resolver las tareas recursivas de manera m√°s natural.\nPara garantizar el final de una funci√≥n recursiva, las sucesivas llamadas tienen que reducir el grado de complejidad del problema, hasta que este pueda resolverse directamente sin necesidad de volver a llamar a la funci√≥n.\n\n\n\n\n\n\nPrecauci√≥n\n\n\n\nLa recursi√≥n es una t√©cnica que suele ser poco eficiente computacionalmente y conviene evitarla siempre que sea posible.\n\n\n\n5.8.1 Ejemplo de funciones recursivas\njulia&gt; function factorial(n::Integer)\n         if n &lt;= 1\n           return 1\n         else\n           return n * factorial(n-1)\n         end\n       end\nfactorial (generic function with 1 method)\n\njulia&gt; factorial(4)\n24\n\njulia&gt; fib(n::Integer) = n ‚â§ 2 ? 1 : fib(n - 1) + fib(n - 2)\nfib (generic function with 1 method)\n\njulia&gt; fib(10)\n55"
  },
  {
    "objectID": "graficos.html#paquetes-gr√°ficos",
    "href": "graficos.html#paquetes-gr√°ficos",
    "title": "6¬† Gr√°ficos",
    "section": "6.1 Paquetes gr√°ficos",
    "text": "6.1 Paquetes gr√°ficos\nExisten muchos paquetes para la representaci√≥n gr√°fica en Julia. Los m√°s usados son:\n\nPlots.jl\nMakie.jl\nGadFly.jl.\nVegaLite.jl"
  },
  {
    "objectID": "graficos.html#gr√°ficos-con-el-paquete-plots.jl",
    "href": "graficos.html#gr√°ficos-con-el-paquete-plots.jl",
    "title": "6¬† Gr√°ficos",
    "section": "6.2 Gr√°ficos con el paquete Plots.jl",
    "text": "6.2 Gr√°ficos con el paquete Plots.jl\nPlots.js es el paquete m√°s usado por disponer de m√°s posibilidades gr√°ficas y ser bastante sencillo de usar.\nImplementa una interfaz para otras librer√≠as gr√°ficas (backends), por lo que en algunas ocasiones puede ser bastante lento al tener que llamar a otras librer√≠as.\n\n\n6.2.1 Backends de Plot.jl\n\nGR. Es el backend pro defecto. Es bastante r√°pida y permite tanto gr√°ficos 2D como 3D no interactivos. Se inicializa con la funci√≥n gr(). (Ver ejemplos)\nPlotlyJS. Es m√°s lenta pero permite gr√°ficos 2D y 3D interactivos con un mont√≥n de funcionalidades. Se inicializa con la funci√≥n plotlyjs(). (Ver ejemplos)\nPyPlot. Utiliza la librer√≠a gr√°fica Matplotlib de Python por lo que es bastante lenta. Sin embargo, tiene ofrece todas las posibilidades de Matplotlib que es bastante madura. Se inicializa con la funci√≥n pyplot(). (Ver ejemplos)\nPGFPlotsX. Utiliza la librer√≠a PGF/TikZ de LaTeX por lo que genera gr√°ficos de muy alta calidad tanto en 2D como 3D, especialmente para publicaciones.Se inicializa con la funci√≥n pgfplotsx(). (Ver ejemplos)\nUnicodePlots. Permite dibujar gr√°ficos en la terminal. Los gr√°ficos son de poca calidad pero funciona con gran rapidez. Se inicializa con la funci√≥n unicodeplots(). (Ver ejemplos)\n\n\n\n6.2.2 Gr√°fica de una funci√≥n de una variable\n\nplot(f, min, max): Dibuja la gr√°fica de la funci√≥n de una variable f para argumentos desde xmin a xmax.\n\n\nusing Plots\n\nf(x) = exp(-x^2 / 2)\nplot(f, -3, 3)\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n6.2.3 Gr√°ficas de varias funciones\n\nplot!(f, xmin, xmax): A√±ade la gr√°fica de la funci√≥n de una variable f para argumentos desde xmin a xmax al √∫ltimo gr√°fico realizado.\n\n\nusing Plots\n\nf(x) = sin(x)\ng(x) = cos(x)\nplot(f, -0, 2œÄ)\nplot!(g)\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n6.2.4 A√±adir puntos a una gr√°fica\n\nscatter(x, y): Dibuja los puntos con coordenadas x en el vector x y coordenadas y en el vector y.\n\n\nusing Plots\n\nf(x) = sin(x)\ng(x) = cos(x)\nplot(f, -0, 2œÄ)\nplot!(g)\nx = [œÄ/4, 5œÄ/4]\ny = sin.(x)\nscatter!(x, y)\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n6.2.5 Ventana de graficaci√≥n\nEs posible restringir el √°rea de graficaci√≥n (rango de valores de los ejes) de una funci√≥n a√±adiendo los par√°metros xlims =(xmin, xmax) para establecer el rango del eje x o ylims = (ymin, ymax) para establecer el rango del eje y.\n\nusing Plots\n\nf(x) = 1 / x\nplot(f, -1, 1, ylims = (-10, 10))\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n6.2.6 Restringir la gr√°fica al dominio\nCuando una funci√≥n no est√° definida para alg√∫n valor del rango de valores del eje x dado, la gr√°fica muestra una l√≠nea recta desde el punto de la gr√°fica anterior hasta el punto siguiente al punto donde la funci√≥n no existe.\nEste comportamiento no es deseable puesto que si la funci√≥n no existe en un punto no deber√≠a existir gr√°fica para ese punto.\nLa siguiente funci√≥n del paquete MTH229 se encarga de evitar esto.\n\nrangeclamp(f): Devuelve una funci√≥n id√©ntica a la funci√≥n f excepto para los puntos donde la funci√≥n no existe o es infinito que devuelve NaN.\n\n\n\n6.2.7 Ejemplo de restringir la gr√°fica al dominio\n\nusing Plots\nusing MTH229\n\nf(x) = 1 / x\nplot(rangeclamp(f), -1, 1)\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n6.2.8 Gr√°ficas param√©tricas\nLa funci√≥n plot tambi√©n permite dibujar gr√°ficas de funciones param√©tricas pas√°ndole las funciones de las coordenadas x e y.\n\nplot(f, g, min, max): Dibuja la gr√°fica de la funci√≥n param√©trica \\((f(t), g(t))\\) para valores del par√°metro t entre min y max.\n\n\nusing Plots\nf(x) = sin(x)\ng(x) = sin(2x)\nplot(f, g, 0, 2œÄ)\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n6.2.9 Personalizaci√≥n de gr√°ficos\nLos siguientes par√°metros pueden a√±adirse a la funci√≥n plot para modificar el aspecto de los gr√°ficos.\n\ntitle: A√±ade un t√≠tulo principal al gr√°fico.\nxlab: A√±ade un t√≠tulo al eje x.\nylab: A√±ade un t√≠tulo al eje y.\ncolor: Establece el color de la gr√°fica.\nlinewidth: Establece el grosor de la l√≠nea de la gr√°fica.\nlinestyle: Establece el estilo de la l√≠nea de la gr√°fica.\naspect_ratio: Establece la relaci√≥n de aspecto entre la escala de los ejes.\nlegend: Activa o desactiva la leyenda del gr√°fico.\n\n\n\n6.2.10 Ejemplo de personalizaci√≥n de gr√°ficos\n\nusing Plots\n\nf(x) = sin(x)\nplot(f, -œÄ, œÄ, title = \"Gr√°fica del seno\",  xlab = \"x\", ylab = \"f(x) = sen(x)\",\n  color = \"green\", linewidth = 3, linestyle = :dash, legend = false)\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n6.2.11 Gr√°ficos en el espacio real\nPara dibujar superficies en el espacio real se utiliza la funci√≥n\nsurface(x, y, f): Dibuja la superficie de la funci√≥n \\(f(x,y)\\) en el rango de valores x del eje x e y del eje y.\n\nusing Plots\nxs = ys = range(1, stop=10, length=100)\nf(x, y) = sin(x) + cos(y)\nsurface(xs, ys, f)"
  },
  {
    "objectID": "graficos.html#gr√°ficos-con-makie",
    "href": "graficos.html#gr√°ficos-con-makie",
    "title": "6¬† Gr√°ficos",
    "section": "6.3 Gr√°ficos con Makie",
    "text": "6.3 Gr√°ficos con Makie\n\nMakie es una colecci√≥n de paquetes de visualizaci√≥n de datos eficiente y extensible que incorpora una gran variedad de tipos de gr√°ficos tanto en 2D como en 3D.\n\n6.3.1 Backends de Makie\nAl igual que el paquete Plots, Makie utiliza distintos backends para construir el gr√°fico seg√∫n la salida que se quiera.\n\nCairoMakie.jl se utiliza para crear gr√°ficos no interactivos de alta calidad, especialmente para publicaciones impresas.\nGLMakie.jl se utiliza para crear gr√°ficos interactivos tanto en 2D como en 3D en una ventana gr√°fica.\nWGLMakie.jl es similar a GLMakie.jl pero muestra el gr√°fico en un navegador web.\n\n\n\n6.3.2 Figuras, ejes y objetos gr√°ficos\nUn gr√°fico con Makie es b√°sicamente una figura (Figure) que contiene uno o varios ejes (Axis) que, a su vez, contienen objetos gr√°ficos como puntos o lineas.\nPara crear una figura se utiliza la funci√≥n\n\nFigure(par√°metros): Crea un √°rea gr√°fica con la configuraci√≥n indicada por los par√°metros. Entre los par√°metros se puede indicar la resoluci√≥n (resolution = (ancho, largo)) o el color de fondo (backgroundcolor = color).\n\n\nusing GLMakie\nfig = Figure(backgroundcolor = :gray, resolution = (400, 300))\n\n\n\n\nPara a√±adir unos ejes en 2D a una figura se utiliza la funci√≥n\n\nAxis(fig[i,j], title = titulo, xlabel = etiqueta-x, ylabel = etiqueta-y): Crea unos ejes en la figura fig con el t√≠tulo principal dado en titulo, la etiqueta del eje \\(x\\) dada en etiqueta-x y la etiqueta del eje \\(y\\) dada en etiqueta-y.\nCuando se quiere incluir varios ejes en una misma figura, el vector [i,j], indica la posici√≥n de los ejes, donde la primera componente indica la fila y la segunda la columna en una disposici√≥n de los ejes en forma de tabla. Si la figura solo contiene unos ejes, se utiliza el vector [1,1].\n\n\nfig = Figure()\nax = Axis(fig[1,1], title = \"Ejes 2D\", xlabel = \"Eje x\", ylabel = \"Eje y\")\nfig\n\n\n\n\nY para a√±adir unos ejes en 3D a una figura se utiliza la funci√≥n\n\nAxis3(fig[i,j], title = titulo, xlabel = etiqueta-x, ylabel = etiqueta-y, zlabel = etiqueta-z, azimuth = √°ngulo-azimuth, elevation = √°ngulo-elevaci√≥n): Crea unos ejes 3D en la figura fig con el t√≠tulo principal dado en titulo, la etiqueta del eje \\(x\\) dada en etiqueta-x, la etiqueta del eje \\(y\\) dada en etiqueta-y, la etiqueta del eje \\(z\\) dada en etiqueta-z, y un punto de visi√≥n dado por el √°ngulo de azimuth (izquierda-derecha) angulo-azimuth radianes (\\(1.275 \\pi\\) por defecto) y el √°ngulo de elevaci√≥n (arriba-abajo) √°ngulo-elevaci√≥n radianes (\\(\\pi/8\\) por defecto). Al igual que antes, cuando se quiere incluir varios ejes en una misma figura, el vector [i,j], indica la posici√≥n de los ejes, donde la primera componente indica la fila y la segunda la columna en una disposici√≥n de los ejes en forma de tabla. Si la figura solo contiene unos ejes, se utiliza el vector [1,1].\n\n\nfig = Figure()\nax = Axis3(fig[1,1], title = \"Ejes 3D\", xlabel = \"Eje x\", ylabel = \"Eje y\", zlabel = \"Eje z\")\nfig\n\n\n\n\n\nfig = Figure()\nax = Axis3(fig[1,1], title = \"Ejes 3D rotados\", xlabel = \"Eje x\", ylabel = \"Eje y\", zlabel = \"Eje z\", azimuth = pi/8)\nfig\n\n\n\n\n\n\n6.3.3 Diagrama de puntos\nPara dibujar un diagrama de puntos se utiliza la funci√≥n\n\nscatter!(ax, xs, ys): Dibuja los ejes dados en ax los puntos con coordenadas dadas por los vectores xs e ys.\n\n\nfig = Figure()\nax = Axis(fig[1, 1], title = \"Diagrama de puntos\")\nxs = [1, 2, 3]\nys = [2, 3, 1]\nMakie.scatter!(ax, xs, ys)\nfig\n\n\n\n\nLos siguientes par√°metros pueden a√±adirse a la funci√≥n anterior para modificar el aspecto del diagrama de puntos.\n\nmarker: Establece el tipo de punto.\ncolor: Establece el color de los puntos.\nmarkersize: Establece el tama√±o de los puntos.\n\n\nfig = Figure()\nax = Axis(fig[1, 1], title = \"Diagrama de puntos\")\nxs = [1, 2, 3]\nys = [2, 3, 1]\nMakie.scatter!(ax, xs, ys, marker = :utriangle, color= :red, markersize = 20)\nfig\n\n\n\n\n\n\n6.3.4 Diagrama de l√≠neas\nPara dibujar series de l√≠neas se utiliza la funci√≥n\n\nlines!(ax, xs, ys): Dibuja en los ejes dados por ax una l√≠nea en el plano que une los puntos con coordenadas dadas por los vectores xs e ys.\n\n\nfig = Figure()\nax = Axis(fig[1, 1], title = \"Diagrama de l√≠neas\")\nxs = range(0, 2pi, length = 100)\nys = sin.(xs)\nlines!(ax, xs, ys)\nfig\n\n\n\n\nSi se a√±ade un tercer vector de coordenadas zs sobre unos ejes 3D, se obtiene un diagrama de l√≠neas en 3D. De esta forma se pueden representar, por ejemplo, la trayectorias de funciones vectoriales.\n\nfig = Figure()\nax = Axis3(fig[1, 1], title = \"Diagrama de l√≠neas 3D\")\nts = range(0, 6pi, length = 200)\nxs = cos.(ts)\nys = sin.(ts)\nzs = ts/4\nlines!(ax, xs, ys, zs)\nfig\n\n\n\n\nEn lugar de pasar las coordenadas de los puntos en vectores separados, se pueden pasar empaquetadas en tuplas mediante las estructuras Point(x,y) para el plano real o Point3(x,y,z) para el espacio real, del paquete GeometryBasics.jl.\n\nfig = Figure()\nax = Axis(fig[1, 1], title = \"Diagrama de lineas\")\nts = range(0, 2pi, length = 200)\npoints = Point.(cos.(ts), sin.(2ts))\nlines!(ax, points)\nfig\n\n\n\n\n\nfig = Figure()\nax = Axis3(fig[1, 1], title = \"Diagrama de l√≠neas 3D\")\nts = range(0, 6pi, length = 200)\nf(t) = [cos(t), sin(t), t/4]\npoints = Point3.(f.(ts))\nlines!(ax, points)\nfig\n\n\n\n\nEn el caso de figuras en 3D, es preferible utilizar los backend GLMakie.jl o WGLMakie.jl ya que permiten interaccionar con el el gr√°fico para visualizarlo desde distintas perspectivas.\n\nfig = Figure()\nax = Axis3(fig[1, 1], title = \"Diagrama de l√≠neas 3D\")\nts = range(0, 6pi, length = 200)\nf(t) = [cos(t), sin(t), t/4]\npoints = Point3.(f.(ts))\nlines!(ax, points)\nfig\n\n\n\n\nTambi√©n es posible pasar a la funci√≥n lines! un rango de valores y una funci√≥n a dibujar. Esto simplifica la creaci√≥n de gr√°ficas de funciones.\n\nlines(ax, rango, funci√≥n): Dibuja en los ejes dados por ax la gr√°fica de la funci√≥n dada en funci√≥n en el intervalo dado por rango. El intervalo del rango se especifica con la sintaxis li..ls, donde li es el l√≠mite inferior y ls el l√≠mite superior.\n\n\nfig = Figure()\nax = Axis(fig[1, 1], title = \"Diagrama de l√≠neas\")\nlines!(ax, 0..2pi, cos)\nfig\n\n\n\n\nPara a√±adir nuevas l√≠neas al los ejes, basta con volver a usar la funci√≥n lines!.\n\nfig = Figure()\nax = Axis(fig[1, 1], title = \"Diagrama de l√≠neas\")\nlines!(ax, 0..2pi, cos)\nlines!(ax, 0..3pi, sin)\nfig\n\n\n\n\nLos siguientes par√°metros pueden a√±adirse a la funci√≥n anterior para modificar el aspecto del diagrama de puntos.\n\nlinewidth: Establece el grosor de la l√≠nea de la gr√°fica.\nlinestyle: Establece el estilo de la l√≠nea de la gr√°fica.\ncolor: Establece el color de la linea.\n\n\nfig = Figure()\nax = Axis(fig[1, 1], title = \"Diagrama de l√≠neas\")\nlines!(ax, 0..2pi, cos, linewidth = 5, linestyle = :dash, color = :red)\nlines!(ax, 0..2pi, sin, linestyle = :dot, color = :green)\nfig\n\n\n\n\n\n\n6.3.5 Superficies\nPara dibujar superficies en 3D se utiliza la funci√≥n\n\nsurface!(ax, xs, ys, zs): Dibuja en los ejes 3D dados por ax la superficie que se obtiene al unir los puntos con coordenadas \\(x\\) dadas por el vector xs, coordenadas y dadas por el vector ys y coordenadas \\(z\\) dadas por el vector zs.\n\n\nusing WGLMakie\nWGLMakie.activate!()\nfig = Figure()\nax = Axis3(fig[1, 1], title = \"Superficie\")\nxs = ys = LinRange(0, 10, 100)\nzs = [cos(x) * sin(y) for x in xs, y in ys]\nWGLMakie.surface!(ax, xs, ys, zs)\nfig\n\n\n  \n    \n      \n      \n    \n    \n      \n      \n    \n  \n  \n    \n      \n        \n      \n    \n    \n      \n      \n    \n  \n\n\n\n\n\n6.3.6 Leyenda\nSi tenemos m√°s de una serie de datos representada en un diagrama, conviene a√±adir una leyenda para identificar cada serie. Podemos a√±adir una leyenda con la funci√≥n\n\naxislegend(ax): A√±ade una leyenda a los ejes dados en ax, con las etiquetas de cada serie de datos incluida en los ejes. Para ello es necesario etiquetar cada serie de datos pas√°ndole el par√°metro label = etiqueta a la funci√≥n que crea el objeto gr√°fico que representa la serie.\n\n\nfig = Figure()\nax = Axis(fig[1, 1], title = \"Diagrama de l√≠neas con leyenda\")\nlines!(ax, 0..2pi, cos, label = \"Coseno\")\nlines!(ax, 0..2pi, sin, label = \"Seno\")\naxislegend()\ncurrent_figure()"
  },
  {
    "objectID": "graficos.html#gr√°ficos-con-gadfly.jl",
    "href": "graficos.html#gr√°ficos-con-gadfly.jl",
    "title": "6¬† Gr√°ficos",
    "section": "6.4 Gr√°ficos con GadFly.jl",
    "text": "6.4 Gr√°ficos con GadFly.jl\nGadFly.js es un paquete nativo que genera gr√°ficos interactivos 2D y 3D por medio de librer√≠as de Javascript basadas en la gram√°tica de gr√°ficos (usada tambi√©n por el paquete ggplot2 de R).\nAl estar implementado en Julia es mucho m√°s r√°pido que Plots.js pero ofrece menos posibilidades."
  },
  {
    "objectID": "graficos.html#gr√°ficos-con-vegalite.jl",
    "href": "graficos.html#gr√°ficos-con-vegalite.jl",
    "title": "6¬† Gr√°ficos",
    "section": "6.5 Gr√°ficos con VegaLite.jl",
    "text": "6.5 Gr√°ficos con VegaLite.jl\nVegaLite.jl es un paquete que genera gr√°ficos est√°ticos por medio de las librer√≠as de Javascript de la gram√°tica de gr√°ficos Vega.\nDispone de muchas m√°s opciones de personalizaci√≥n de gr√°ficos que GadFly.jl."
  },
  {
    "objectID": "calculo-simbolico.html#symbolics.jl",
    "href": "calculo-simbolico.html#symbolics.jl",
    "title": "7¬† C√°lculo simb√≥lico",
    "section": "7.1 Symbolics.jl",
    "text": "7.1 Symbolics.jl\nSymbolics.jl es un paquete que implementa un avanzado Sistema de √Ålgebra Computacional (CAS) basado en un lenguaje de modelado simb√≥lico.\nLas variables y las expresiones simb√≥licas pueden utilizarse con la mayor√≠a de las funciones de Julia para c√°lculo num√©rico, por lo que se integran a la perfecci√≥n en el ecosistema de Julia.\n\n\n7.1.1 Variables y expresiones simb√≥licas\nPara declarar variables simb√≥licas se utiliza la siguiente macro:\n\n@variables x y ...: Declara las variables x, y, etc. como variables simb√≥licas.\n\nEl tipo de las variables simb√≥licas es Num.\nCualquier expresi√≥n en la que interviene una variable simb√≥lica se convierte autom√°ticamente en una expresi√≥n simb√≥lica.\n\n\n7.1.2 Ejemplo de variables y expresiones simb√≥licas\nusing Symbolics\n\njulia&gt; @variables x y\n2-element Vector{Num}:\n x\n y\n\njulia&gt; z = x^2 - y\nx^2 - y\n\njulia&gt; typeof(z)\nNum\n\njulia&gt; A = [x + y 2x; -y y - x]  # Matriz simb√≥lica\n2√ó2 Matrix{Num}:\n x + y     2x\n    -y  y - x\n\n\n7.1.3 √Ålgebra simb√≥lica\nSe pueden realizar operaciones algebraicas con expresiones simb√≥licas utilizando los mismos operadores del √Ålgebra num√©rica.\nusing Symbolics\n\njulia&gt; @variables x y;\n\njulia&gt; (x + 1) + (x + 2)\n3 + 2x\n\njulia&gt; A = [x + y 2x; -y y - x]  # Matriz simb√≥lica\n2√ó2 Matrix{Num}:\n x + y     2x\n    -y  y - x\n\njulia&gt; B = [x, y]  # Vector simb√≥lico\n2-element Vector{Num}:\n x\n y\n\njulia&gt; A * B  # Producto matricial\n2-element Vector{Num}:\n x*(x + y) + 2x*y\n  y*(y - x) - x*y\n\n\n7.1.4 Simplificaci√≥n de expresiones\nPara simplificar expresiones simb√≥licas se utiliza la siguiente funci√≥n:\n\nsimplify(e): Devuelve la expresi√≥n simb√≥lica que resulta de simplificar la expresi√≥n simb√≥lica e.\n\nLa simplificaci√≥n utiliza el paquete SymbolicUtils.jl que implementa un potente sistema de reescritura de t√©rminos.\nusing Symbolics\n\n@variables x y;\n\njulia&gt; simplify(2(x+y))\n2x + 2y\n\njulia&gt; simplify(2(x+y))\n2x + 2y\n\njulia&gt; simplify(sin(x)^2 + cos(x)^2)\n1\n\n\n7.1.5 Sustituci√≥n de variables en expresiones\nPara sustituir una variable simb√≥lica en una expresi√≥n se utiliza la siguiente funci√≥n:\n\nsubstitute(e, d): Realiza la sustituci√≥n de las claves por los valores del diccionario d en la expresi√≥n simb√≥lica e.\n\nusing Symbolics\n\n@variables x y;\n\njulia&gt; substitute(cos(2x), Dict([x =&gt; œÄ])) \n1.0\n\njulia&gt; substitute(x * y + 2x -y + 2, Dict([x =&gt; 1, y =&gt; 2]))\n4\n\n\n7.1.6 Resoluci√≥n de ecuaciones\nPara definir una ecuaci√≥n se utiliza el s√≠mbolo ~ en lugar de la igualdad.\nPara resolver una ecuaci√≥n se utiliza la siguiente funci√≥n:\n\nSymbolics.solve_for(eq, var): Devuelve un vector con los valores de las variables del vector var que cumplen la ecuaci√≥n o sistema de ecuaciones eq, siempre que la ecuaci√≥n tenga soluci√≥n.\n\n\n\n\n\n\n\nAdvertencia\n\n\n\nActualmente solo funciona para ecuaciones lineales.\n\n\nusing Symbolics\n\n@variables x y;\n\njulia&gt; Symbolics.solve_for(x + y ~ 0, x)\n-y\n\njulia&gt; Symbolics.solve_for([x + y ~ 4, x - y ~ 2], [x, y])\n2-element Vector{Float64}:\n 3.0\n 1.0\n\n\n7.1.7 C√°lculo de derivadas\nPara calcular la derivada de una funci√≥n se utiliza la siguiente funci√≥n:\n\nSymbolics.derivative(f, x): Devuelve la expresi√≥n simb√≥lica de la derivada de la funci√≥n f con respecto a la variable simb√≥lica x.\n\nusing Symbolics\n\njulia&gt; @variables x y;\n\njulia&gt; Symbolics.derivative(exp(x*y), x)\ny*exp(x*y)\n\njulia&gt; Symbolics.derivative(Symbolics.derivative(exp(x*y), x), y)\nx*y*exp(x*y) + exp(x*y)\n\n\n7.1.8 C√°lculo de derivadas con operadores diferenciales\nPara construir un operador diferencial (\\(\\frac{d}{dx}\\)) se utiliza la siguiente funci√≥n:\n\nDifferential(x): Crea el operador diferencial con respecto a la variable simb√≥lica x.\n\nPara obtener la funci√≥n derivada, una vez aplicado el operador diferencial a una funci√≥n, es necesario aplicar la siguiente funci√≥n:\n\nexpand_derivatives(D(f)): Devuelve la expresi√≥n simb√≥lica que corresponde a la derivada de la funci√≥n f con respecto a la variable del operador diferencial D.\n\n\n\n7.1.9 Ejemplo de c√°lculo de derivadas con operadores diferenciales\nusing Symbolics\n\n@variables x y;\n\njulia&gt; Dx = Differential(x)\n(::Differential) (generic function with 2 methods)\n\njulia&gt; f(x) = sin(x^2)\nf (generic function with 1 method)\n\njulia&gt; f1(x) = Dx(f(x))\nf1 (generic function with 1 method)\n\njulia&gt; expand_derivatives(f1(x))\n2x*cos(x^2)\n\njulia&gt; Dy = Differential(y)\n(::Differential) (generic function with 2 methods)\n\njulia&gt; expand_derivatives(Dx(Dy(cos(x*y))))\n-sin(x*y) - x*y*cos(x*y)\n\n\n7.1.10 Gradiente y matriz Hessiana de una funci√≥n de varias variables\nPara calcular el vector gradiente de una funci√≥n de varias variables se utiliza la siguiente funci√≥n:\n\nSymbolics.gradient(f, vars): Devuelve el vector gradiente de la funci√≥n f con respecto a las variables del vector vars.\n\nY para calcular la matriz Hessiana se utiliza la siguiente funci√≥n:\n\nSymbolics.hessian(f, vars): Devuelve la matriz Hessiana de la funci√≥n f con respecto a las variables del vector vars.\n\n\n\n7.1.11 Ejemplo de gradiente y matriz Hessiana de una funci√≥n de varias variables\nusing Symbolics\n\n@variables x y;\n\njulia&gt; Symbolics.gradient(exp(x*y), [x, y])\n2-element Vector{Num}:\n y*exp(x*y)\n x*exp(x*y)\n\njulia&gt; Symbolics.hessian(exp(x*y), [x, y])\n2√ó2 Matrix{Num}:\n (y^2)*exp(x*y)               x*y*exp(x*y) + exp(x*y)\n   x*y*exp(x*y) + exp(x*y)  (x^2)*exp(x*y)"
  },
  {
    "objectID": "analisis-datos.html#el-paquete-dataframes.jl",
    "href": "analisis-datos.html#el-paquete-dataframes.jl",
    "title": "8¬† An√°lisis de datos",
    "section": "8.1 El paquete DataFrames.jl",
    "text": "8.1 El paquete DataFrames.jl\nEl principal paquete para an√°lisis de datos es DataFrames.jl que proporciona herramientas para trabajar con conjuntos de datos en formato de tabla de forma similar a pandas en Python o data.frames y dplyr en R.\nEn conjunci√≥n con este paquete es frecuente utilizar tambi√©n alguno de los siguientes paquetes:\n\nFreqTables.jl. Funciones para la construcci√≥n de tablas de frecuencias.\nStatistics.jl. Funciones para los principales estad√≠sticos descriptivos.\nHypothesisTests.jl Funciones para los contrastes de hip√≥tesis param√©tricos y no param√©tricos m√°s comunes.\nGLM.jl. Funciones para modelos lineales generales.\nMultivariateStats.jl. Funciones para an√°lisis multivariante.\nMLJ.jl. Funciones para los principales algoritmos de aprendizaje autom√°tico.\n\n\n8.1.1 Creaci√≥n de DataFrames\nPara crear un DataFrame su utiliza la siguiente funci√≥n:\n\nDataFrame(x1=v1, x2=v2, ...): Devuelve el DataFrame que formado por las columnas de los vectores v1, v2, etc, con los nombres x1, x2, etc, respectivamente.\n\nusing DataFrames\n\njulia&gt; df = DataFrame(Nombre = [\"Mar√≠a\", \"Luis\", \"Carmen\"], Edad = [22, 18, 20])\n3√ó2 DataFrame\n Row ‚îÇ Nombre  Edad  \n     ‚îÇ String  Int64 \n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n   1 ‚îÇ Mar√≠a      22\n   2 ‚îÇ Luis       18\n   3 ‚îÇ Carmen     20\n\n\n8.1.2 Creaci√≥n de DataFrames desde una url\nPara crear una DataFrame a partir de un fichero csv en la nube, se utiliza la siguiente funci√≥n del paquete CSV.jl:\n\nCSV.read(download(url), DataFrame): Devuelve el DataFrame que resulta de importar el fichero csv con la url url.\n\nusing DataFrames, CSV\n\njulia&gt; df = CSV.read(download(\"https://raw.githubusercontent.com/asalber/manual-python/master/datos/colesteroles.csv\"), DataFrame)\n14√ó6 DataFrame\n Row ‚îÇ nombre                           edad   sexo     peso     altura   colesterol \n     ‚îÇ String                           Int64  String1  Int64?   String7  Int64?     \n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n   1 ‚îÇ Jos√© Luis Mart√≠nez Izquierdo        18  H             85  1,79            182\n   2 ‚îÇ Rosa D√≠az D√≠az                      32  M             65  1,73            232\n   3 ‚îÇ Javier Garc√≠a S√°nchez               24  H        missing  1,81            191\n   4 ‚îÇ Carmen L√≥pez Pinz√≥n                 35  M             65  1,70            200\n   5 ‚îÇ Marisa L√≥pez Collado                46  M             51  1,58            148\n   6 ‚îÇ Antonio Ruiz Cruz                   68  H             66  1,74            249\n   7 ‚îÇ Antonio Fern√°ndez Oca√±a             51  H             62  1,72            276\n   8 ‚îÇ Pilar Mart√≠n Gonz√°lez               22  M             60  1,66        missing \n   9 ‚îÇ Pedro G√°lvez Tenorio                35  H             90  1,94            241\n  10 ‚îÇ Santiago Reillo Manzano             46  H             75  1,85            280\n  11 ‚îÇ Macarena √Ålvarez Luna               53  M             55  1,62            262\n  12 ‚îÇ Jos√© Mar√≠a de la Gu√≠a Sanz          58  H             78  1,87            198\n  13 ‚îÇ Miguel Angel Cuadrado Guti√©rrez     27  H            109  1,98            210\n  14 ‚îÇ Carolina Rubio Moreno               20  M             61  1,77            194"
  },
  {
    "objectID": "aplicaciones.html#teor√≠a-de-grafos",
    "href": "aplicaciones.html#teor√≠a-de-grafos",
    "title": "9¬† Otras aplicaciones",
    "section": "9.1 Teor√≠a de grafos",
    "text": "9.1 Teor√≠a de grafos\n\nJuliaGraphs. An√°lisis de grafos en Julia.\nGraphs. Creaci√≥n y an√°lisis de grafos.\nGraphPlot. Dibujo de grafos."
  },
  {
    "objectID": "aplicaciones.html#c√°lculo-simb√≥lico",
    "href": "aplicaciones.html#c√°lculo-simb√≥lico",
    "title": "9¬† Otras aplicaciones",
    "section": "9.2 C√°lculo simb√≥lico",
    "text": "9.2 C√°lculo simb√≥lico\n\nSymPy. Sistema de √Ålgebra Computacional (CAS) basdado en la librer√≠a SymPy de Python.\nSymbolics Sistema de √Ålgebra Computacional (CAS) basado en Julia."
  },
  {
    "objectID": "aplicaciones.html#aprendizaje-autom√°tico",
    "href": "aplicaciones.html#aprendizaje-autom√°tico",
    "title": "9¬† Otras aplicaciones",
    "section": "9.3 Aprendizaje autom√°tico",
    "text": "9.3 Aprendizaje autom√°tico\n\nMLJ.jl. Funciones para los principales algoritmos de aprendizaje autom√°tico."
  }
]